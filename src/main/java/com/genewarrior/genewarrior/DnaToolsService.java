/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */
package com.genewarrior.genewarrior;

import com.genewarrior.genetools.alignment.*;
import com.genewarrior.genetools.sequenceHandling.*;
import com.genewarrior.genewarrior.outputTypes.*;
import com.google.gson.Gson;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import org.springframework.util.MultiValueMap;

import java.io.*;
import java.math.BigInteger;
import java.security.SecureRandom;
import java.sql.Date;
import java.util.*;

@Service
public class DnaToolsService {
    @Value("${website.address}")
    private String httpAddress;

    @Value("${software.directory}")
    private String softwareDir;

    private final SecureRandom random = new SecureRandom();
    SubstitutionMatrix sms_dna = (new SubstitutionMatricesDNA()).dna;
    SubstitutionMatrix sms_aa = (new SubstitutionMatricesBlosum2()).blosum[7];
    Aminoacids aa = new Aminoacids();
    Nucleotide nucl = new Nucleotide();
    Gson gson = new Gson();

    @Autowired
    ProjectEntityRepository projectEntityRepository;

    protected String processRequest(MultiValueMap<String, String> allRequestParams) {
        String type = allRequestParams.getFirst("type");
        String text = allRequestParams.getFirst("text");
        String title = allRequestParams.getFirst("title");
        String reverse = allRequestParams.getFirst("reverse");
        String noMarks = allRequestParams.getFirst("noMarks");
        String pos = allRequestParams.getFirst("pos");
        String bothStrands = allRequestParams.getFirst("bothStrands");
        String searchFor = allRequestParams.getFirst("searchFor");
        String filename = allRequestParams.getFirst("filename");
        String seqType = allRequestParams.getFirst("seqType");
        String alignmentType = allRequestParams.getFirst("alignmentType");
        String translationTable = allRequestParams.getFirst("translationTable");
        String start = allRequestParams.getFirst("start");
        String end = allRequestParams.getFirst("end");
        String frame = allRequestParams.getFirst("frame");
        String key = allRequestParams.getFirst("key");
        String color = allRequestParams.getFirst("color");
        String annotation = allRequestParams.getFirst("annotation");

        switch (type) {
            case "addSequences":
                return addSequences(text);
            case "RevComp":
            case "Rev":
            case "Comp":
                return revComp(text, type, pos);
            case "highlightSequence":
                return highlightSequence(text, pos, start, end, color, annotation);
            case "getSubsequence":
                return getSubsequence(text, title, reverse, noMarks, start, end);
            case "addCustomText":
                return addCustomText(text, title, pos);
            case "findSequenceDNA":
                return findSequenceDNA(text, bothStrands, searchFor);
            case "findSequenceAA":
                return findSequenceAA(text, searchFor);
            case "loadExample":
                return loadExample();
            case "validateDNA":
                return validateDNA(text);
            case "validateAA":
                return validateAA(text);
            case "validateName":
                return validateName(text);
            case "alignPw":
                return alignPw(text, seqType, alignmentType);
            case "alignMultiple":
                return multipleSequenceAlignment(text, seqType);
            case "translate":
                return translate(text, translationTable, frame, start, end);
            case "translateWindow":
                return translateWindow(text, translationTable);
            case "alignmentConsensus":
                return alignmentConsensus(text);
            case "alignmentTree":
                return alignmentTree(text);
            case "alignmentLogo":
                return alignmentLogo(text);
            case "longestOrf":
                return longestOrf(text, translationTable);
            case "share":
                return saveToDB(text);
            case "getLink":
                return getDatafromDB(key);
            case "primer3":
                return primer3(allRequestParams);
            default:
                System.out.println("Error: type not found");
                break;
        }
        return "Error";
    }

    private String validateDNA(String text) {
        return convertDNASequence(text);
    }

    private String validateAA(String text) {
        return convertAASequence(text);
    }

    private String validateName(String text) {
        return removeCharsTitle(text);
    }

    private String loadExample() {
//        ArrayList<output> seqs = new ArrayList<>();
//        seqs.add(new dna("[Example] lacZ (beta-galactosidase, Lactococcus lactis)", "AAAATTGTTTTATTCAACCCCCTTTTTATGCTAATTTTGGTGGAAAAAATGTTCATTTTGGAACAGGGATTTATGCTAATTTTAATCTAACATTGGTTGACGATACAGATATTTTTGTAGGAAATCATGTCATGTTTGGACCAAATGTTACGATTGACACGGCGACACATCCTGTCTCGCTTGACTTACGTAAACGAGGGGCTCAATATAATAAAAAAGTTTATATTGAAGAAAATGTTTGGCTAGGTGCTGGTGTAATTGTGTTACCTGGTGTTAGAATTGGGAAAAATAGTGTGATTGGCGCAGGGAGTCTTGTAACTAAAGACATTCCAGATAATGTGGTTGCTTTTGGAACTCCTTGTATGGTTAAAAGAAAAATCAATGATTCTGACTTTAAAACTTATGATCATGGAAAAAAGATTGATTTAGATGAGTTCATCTGAAAGGAATGGCTATGATGACAATGATTGATGTACTAGAGCGTAAAGATTGGGAAAATCCAGTAGTTTCAAATTGGAATAGGTTGCCAATGCATACACCTATGGACTTTTTAGAAAAGCAATCACTGAATGGTCTTTGGAATTTTGATCATTTTTCTAGAATTTCAGATGTACCTAAAAATTGGTTAGAACTGACGGAGAGTAAAACGGAAATTATCGTTCCAAGTAATTGGCAAATAGAATTTAAGGATAAAAGCGATGTTCCAATTTATACAAATGTGACTTATCCTATTCCAATTCAGCCTCCTTATGTGCCAGAGGCTAACCCAGTTGGAGCTTATAGTCGCTATTTTGATATCACAAAAGAATGGCTTGAGAGCGGTCATGTTCACCTTACATTTGAAGGGGTTGGATCAGCTTTTCATTTTTGGTTGAATGGGGAATACGGAGGTTATTCAGAAGATAGCCGCTTGTCTGCTGAATTCGATATCAGCAACCTGGCCAAAGAAGGTCAAAATTGTTTAAAAGTTCTAGTTTTTCGTTGGTCAAAAGGCACCTATTTTGAAGATCAAGATATGTGGCGAATGTCAGGTATTTTTCGTTCGGTGAACTTACAATGGCTTCCAGATAACTACTTGTTAGACTTTTCTATAAAAACAGATTTGGATGAGGATTTAGATTTTGCAAATGTAAAACTTCAAGCATATGCTAAAAACATGGATGATGCTTGTTTAGAATTTAAGCTTTATGATGACGAACAATTAATTGGAGAGTGTCATGGTTTTGATGCAGAAATTGGAGTAGTCAATCCAAAATTATGGTCAGATGAAATTCCCTATCTTTATCGTTTAGAATTAACTTTAATGGACCGGAGTGGGGCGGTATTTCATAAAGAAACAAAAAAAATTGGTATTCGAAAAATTGCTATTGAAAAAGGACAGCTAAAAATAAACGGGAAAGCACTTCTTGTTCGTGGAGTGAATAAGCACGAATTTACCCCTGAGCATGGTTATGTCGTTTCTGAAGAAGTGATGATTAAAGACATCAAATTGATGAAAGAACATAATTTTAATGCGGTCCGCTGCTCTCATTATCCTAATGATTCACGCTGGTATGAATTGTGTGATGAATATGGATTGTATGTTATGGATGAAGCAAATATCGAAACGCATGGAATGACTCCGATGAATCGTTTGACAAATGATCCGACTTATTTACCATTAATGAGTGAACGTGTTACACGAATGGTTATGCGTGACCGTAATCATCCATCAATTATTATTTGGTCTCTTGGGAATGAGTCAGGTTATGGAAGTAACCATCAAGCTTTATATGATTGGTGTAAATCATTTGATTCTAGCCGCCCTGTTCATTATGAGGGGGGAGATGACGCAAGTAGAGGAGCAACAGATGCCACTGATATCATTTGTCCGATGTATGCTAGAGTAGATAGTCCAAGTATTAATGCGCCTTATTCATTAAAAACCTGGATGGGGGTAGCTGGAGAGAATAGACCACTAATTCTTTGTGAATATGCTCATGATATGGGGAATTCATTAGGAGGATTTGGGAAGTACTGGCAAGCTTTTCGAGAAATTGACCGATTGCAAGGTGGATTCATCTGGGATTGGGTGGATCAAGGTTTATTAAAAGATGGAAATTATGCTTATGGAGGTGACTTTGGGGATAAGCCAAATGATCGTCAGTTTAGCCTTAATGGTCTTGTTTTTCCAAATCGTCAAGCAAAACCAGCTCTTCGTGAAGCAAAATATTGGCAACAATATTATCAGTTTGAACTGGAGAAAACTCCACTAGGTCAAGTTTTTGCCTTTACAGTTACAAATGAGTATCTATTTCGAAGTACTGACAATGAAAAATTATGTTACCAACTGACCAATGGCTTAGAAGTATTATGGGAAAATGAGCTTATATTGAATATGCCTGCTGGAGGGTCTATGAGAATAGACCTGTCTGAGTTGCCTATTGATGGAACAGATAATTTATTTTTGAACATTCAAGTTAAAACAATTGAGAAATGTAATCTTCTTGAGTCTGATTTTGAAGTTGCTCATCAACAATTTGTTCTACAAGAAAAAATTAATTTTACTGACAGAATAGATAGTAATGAAGAAATTACACTTTTGGAGGATGAAGAGCTACTGACCGTACGATCAGCAAAACAGAAATTTATTTTTAATAAAAGCAATGGTAATCTCTCGCGCTGGCTTGATGAGAAAGGCAATGAAAAGTTACTGCATGAGCTCTCAGAACAATTTACAAGGGCTCCATTAGATAATGATATTGGTGTTAGTGAAGTTGAACATATTGATCCTAATGCTTGGTTAGAACGTTGGAAGGCTGTTGGCTTTTATGAGTTAAAAACGCTTTTGAAAAATATGATAATACAAGCAACAGAGAATGAAGTAATTATTTCTGTCCAAACAGACTATGAAGCAAAAGGAAAAATTGCATTTTCAACCATTCGAGAATATCATATTTTTAGAAACGGTGAACTTCTTTTAAAAGTTGATTTTAAAAGAAATATAGAGTTTCCAGAACCAGCTCGAATTGGCTTGAGTCTTCAACTAGCTGAAAAAGCAGAAAATGTTACATATTTTGGACTTGGCCCAGATGAAAATTATCCTGACCGAAGAGGGGCAAGTTTATTTGGTCAGTGGAATTTAAGGATTACTGATATGACAACCCCTTATATTTTTCCTAGTGAAAATGGGTTGAGGATGGAAACCAGAGAGCTAAATTATGGTCGTTTAAAAGTTCGGGCAATGGGTCAATCTTTTGCTTTTAATCTAAGTCCATATAGTCAAAACCAGCTTGCTAAAAAGGGACATTGGCATCTACTTGAAGAAGAAGCAGGAACATGGTTAAATATTGACGGATTCCATATGGGTGTAGGTGGAGATGATTCATGGAGTCCAAGTGTCGCTCAGGAATATTTATTGACAAAGGGAAATTATCATTATGAAGTTAGTTTTAAATTAACGTGATGATACAAATTTTCAAGAATTTGATATAATGTAGAGAAAATGGAGGTTCTTATGACGGTTTTAGTTCTTGGTGGAGCAGGATACGTGGGAAGTCACGCGGTAGATATGCTTCTTAAACGTGATTATGATGTGGCAGTGGTGGATAATTTAGTGACAGGCCACCGTGAATCTGTTCCAGCAAATGTACGCTTTTACGAGGGAGATGTGCGTGATCATGCTTTCTTAGCTAGTGTTTTTGAAAAAGAAAATATTGAAGGAATCATGCACTTCTGTGCTTACTCTTTAGTGGGTGAGTCAATGCAAAAACCTTTAATGTATTTTAATAATAATGTTGGTGGTGCTCAAGTAATTCTAGAAACGATGGAAGAATTCGGAGTAAAACATATTGTTTTCTCAAGTACAGCAGCTACATTTGGAATTCCAGAAAAAAGTCCAATTTCAGAAAAAACA", "AAAATTGTTTTATTCAACCCCCTTTTTATGCTAATTTTGGTGGAAAAAATGTTCATTTTGGAACAGGGATTTATGCTAATTTTAATCTAACATTGGTTGACGATACAGATATTTTTGTAGGAAATCATGTCATGTTTGGACCAAATGTTACGATTGACACGGCGACACATCCTGTCTCGCTTGACTTACGTAAACGAGGGGCTCAATATAATAAAAAAGTTTATATTGAAGAAAATGTTTGGCTAGGTGCTGGTGTAATTGTGTTACCTGGTGTTAGAATTGGGAAAAATAGTGTGATTGGCGCAGGGAGTCTTGTAACTAAAGACATTCCAGATAATGTGGTTGCTTTTGGAACTCCTTGTATGGTTAAAAGAAAAATCAATGATTCTGACTTTAAAACTTATGATCATGGAAAAAAGATTGATTTAGATGAGTTCATCTGAAAGGAATGGCTATGATGACAATGATTGATGTACTAGAGCGTAAAGATTGGGAAAATCCAGTAGTTTCAAATTGGAATAGGTTGCCAATGCATACACCTATGGACTTTTTAGAAAAGCAATCACTGAATGGTCTTTGGAATTTTGATCATTTTTCTAGAATTTCAGATGTACCTAAAAATTGGTTAGAACTGACGGAGAGTAAAACGGAAATTATCGTTCCAAGTAATTGGCAAATAGAATTTAAGGATAAAAGCGATGTTCCAATTTATACAAATGTGACTTATCCTATTCCAATTCAGCCTCCTTATGTGCCAGAGGCTAACCCAGTTGGAGCTTATAGTCGCTATTTTGATATCACAAAAGAATGGCTTGAGAGCGGTCATGTTCACCTTACATTTGAAGGGGTTGGATCAGCTTTTCATTTTTGGTTGAATGGGGAATACGGAGGTTATTCAGAAGATAGCCGCTTGTCTGCTGAATTCGATATCAGCAACCTGGCCAAAGAAGGTCAAAATTGTTTAAAAGTTCTAGTTTTTCGTTGGTCAAAAGGCACCTATTTTGAAGATCAAGATATGTGGCGAATGTCAGGTATTTTTCGTTCGGTGAACTTACAATGGCTTCCAGATAACTACTTGTTAGACTTTTCTATAAAAACAGATTTGGATGAGGATTTAGATTTTGCAAATGTAAAACTTCAAGCATATGCTAAAAACATGGATGATGCTTGTTTAGAATTTAAGCTTTATGATGACGAACAATTAATTGGAGAGTGTCATGGTTTTGATGCAGAAATTGGAGTAGTCAATCCAAAATTATGGTCAGATGAAATTCCCTATCTTTATCGTTTAGAATTAACTTTAATGGACCGGAGTGGGGCGGTATTTCATAAAGAAACAAAAAAAATTGGTATTCGAAAAATTGCTATTGAAAAAGGACAGCTAAAAATAAACGGGAAAGCACTTCTTGTTCGTGGAGTGAATAAGCACGAATTTACCCCTGAGCATGGTTATGTCGTTTCTGAAGAAGTGATGATTAAAGACATCAAATTGATGAAAGAACATAATTTTAATGCGGTCCGCTGCTCTCATTATCCTAATGATTCACGCTGGTATGAATTGTGTGATGAATATGGATTGTATGTTATGGATGAAGCAAATATCGAAACGCATGGAATGACTCCGATGAATCGTTTGACAAATGATCCGACTTATTTACCATTAATGAGTGAACGTGTTACACGAATGGTTATGCGTGACCGTAATCATCCATCAATTATTATTTGGTCTCTTGGGAATGAGTCAGGTTATGGAAGTAACCATCAAGCTTTATATGATTGGTGTAAATCATTTGATTCTAGCCGCCCTGTTCATTATGAGGGGGGAGATGACGCAAGTAGAGGAGCAACAGATGCCACTGATATCATTTGTCCGATGTATGCTAGAGTAGATAGTCCAAGTATTAATGCGCCTTATTCATTAAAAACCTGGATGGGGGTAGCTGGAGAGAATAGACCACTAATTCTTTGTGAATATGCTCATGATATGGGGAATTCATTAGGAGGATTTGGGAAGTACTGGCAAGCTTTTCGAGAAATTGACCGATTGCAAGGTGGATTCATCTGGGATTGGGTGGATCAAGGTTTATTAAAAGATGGAAATTATGCTTATGGAGGTGACTTTGGGGATAAGCCAAATGATCGTCAGTTTAGCCTTAATGGTCTTGTTTTTCCAAATCGTCAAGCAAAACCAGCTCTTCGTGAAGCAAAATATTGGCAACAATATTATCAGTTTGAACTGGAGAAAACTCCACTAGGTCAAGTTTTTGCCTTTACAGTTACAAATGAGTATCTATTTCGAAGTACTGACAATGAAAAATTATGTTACCAACTGACCAATGGCTTAGAAGTATTATGGGAAAATGAGCTTATATTGAATATGCCTGCTGGAGGGTCTATGAGAATAGACCTGTCTGAGTTGCCTATTGATGGAACAGATAATTTATTTTTGAACATTCAAGTTAAAACAATTGAGAAATGTAATCTTCTTGAGTCTGATTTTGAAGTTGCTCATCAACAATTTGTTCTACAAGAAAAAATTAATTTTACTGACAGAATAGATAGTAATGAAGAAATTACACTTTTGGAGGATGAAGAGCTACTGACCGTACGATCAGCAAAACAGAAATTTATTTTTAATAAAAGCAATGGTAATCTCTCGCGCTGGCTTGATGAGAAAGGCAATGAAAAGTTACTGCATGAGCTCTCAGAACAATTTACAAGGGCTCCATTAGATAATGATATTGGTGTTAGTGAAGTTGAACATATTGATCCTAATGCTTGGTTAGAACGTTGGAAGGCTGTTGGCTTTTATGAGTTAAAAACGCTTTTGAAAAATATGATAATACAAGCAACAGAGAATGAAGTAATTATTTCTGTCCAAACAGACTATGAAGCAAAAGGAAAAATTGCATTTTCAACCATTCGAGAATATCATATTTTTAGAAACGGTGAACTTCTTTTAAAAGTTGATTTTAAAAGAAATATAGAGTTTCCAGAACCAGCTCGAATTGGCTTGAGTCTTCAACTAGCTGAAAAAGCAGAAAATGTTACATATTTTGGACTTGGCCCAGATGAAAATTATCCTGACCGAAGAGGGGCAAGTTTATTTGGTCAGTGGAATTTAAGGATTACTGATATGACAACCCCTTATATTTTTCCTAGTGAAAATGGGTTGAGGATGGAAACCAGAGAGCTAAATTATGGTCGTTTAAAAGTTCGGGCAATGGGTCAATCTTTTGCTTTTAATCTAAGTCCATATAGTCAAAACCAGCTTGCTAAAAAGGGACATTGGCATCTACTTGAAGAAGAAGCAGGAACATGGTTAAATATTGACGGATTCCATATGGGTGTAGGTGGAGATGATTCATGGAGTCCAAGTGTCGCTCAGGAATATTTATTGACAAAGGGAAATTATCATTATGAAGTTAGTTTTAAATTAACGTGATGATACAAATTTTCAAGAATTTGATATAATGTAGAGAAAATGGAGGTTCTTATGACGGTTTTAGTTCTTGGTGGAGCAGGATACGTGGGAAGTCACGCGGTAGATATGCTTCTTAAACGTGATTATGATGTGGCAGTGGTGGATAATTTAGTGACAGGCCACCGTGAATCTGTTCCAGCAAATGTACGCTTTTACGAGGGAGATGTGCGTGATCATGCTTTCTTAGCTAGTGTTTTTGAAAAAGAAAATATTGAAGGAATCATGCACTTCTGTGCTTACTCTTTAGTGGGTGAGTCAATGCAAAAACCTTTAATGTATTTTAATAATAATGTTGGTGGTGCTCAAGTAATTCTAGAAACGATGGAAGAATTCGGAGTAAAACATATTGTTTTCTCAAGTACAGCAGCTACATTTGGAATTCCAGAAAAAAGTCCAATTTCAGAAAAAACA"));
//        seqs.add(new dna("[Example] lacZ (beta-galactosidase, Escherichia coli)", "TGGCGCTGGGCGCAATGCGCGCCATTACCGAGTCCGGGCTGCGCGTTGGTGCGGATATCTCGGTAGTGGGATACGACGATACCGAAGACAGCTCATGTTATATCCCGCCGTTAACCACCATCAAACAGGATTTTCGCCTGCTGGGGCAAACCAGCGTGGACCGCTTGCTGCAACTCTCTCAGGGCCAGGCGGTGAAGGGCAATCAGCTGTTGCCCGTCTCACTGGTGAAAAGAAAAACCACCCTGGCGCCCAATACGCAAACCGCCTCTCCCCGCGCGTTGGCCGATTCATTAATGCAGCTGGCACGACAGGTTTCCCGACTGGAAAGCGGGCAGTGAGCGCAACGCAATTAATGTGAGTTAGCTCACTCATTAGGCACCCCAGGCTTTACACTTTATGCTTCCGGCTCGTATGTTGTGTGGAATTGTGAGCGGATAACAATTTCACACAGGAAACAGCTATGACCATGATTACGGATTCACTGGCCGTCGTTTTACAACGTCGTGACTGGGAAAACCCTGGCGTTACCCAACTTAATCGCCTTGCAGCACATCCCCCTTTCGCCAGCTGGCGTAATAGCGAAGAGGCCCGCACCGATCGCCCTTCCCAACAGTTGCGCAGCCTGAATGGCGAATGGCGCTTTGCCTGGTTTCCGGCACCAGAAGCGGTGCCGGAAAGCTGGCTGGAGTGCGATCTTCCTGAGGCCGATACTGTCGTCGTCCCCTCAAACTGGCAGATGCACGGTTACGATGCGCCCATCTACACCAACGTGACCTATCCCATTACGGTCAATCCGCCGTTTGTTCCCACGGAGAATCCGACGGGTTGTTACTCGCTCACATTTAATGTTGATGAAAGCTGGCTACAGGAAGGCCAGACGCGAATTATTTTTGATGGCGTTAACTCGGCGTTTCATCTGTGGTGCAACGGGCGCTGGGTCGGTTACGGCCAGGACAGTCGTTTGCCGTCTGAATTTGACCTGAGCGCATTTTTACGCGCCGGAGAAAACCGCCTCGCGGTGATGGTGCTGCGCTGGAGTGACGGCAGTTATCTGGAAGATCAGGATATGTGGCGGATGAGCGGCATTTTCCGTGACGTCTCGTTGCTGCATAAACCGACTACACAAATCAGCGATTTCCATGTTGCCACTCGCTTTAATGATGATTTCAGCCGCGCTGTACTGGAGGCTGAAGTTCAGATGTGCGGCGAGTTGCGTGACTACCTACGGGTAACAGTTTCTTTATGGCAGGGTGAAACGCAGGTCGCCAGCGGCACCGCGCCTTTCGGCGGTGAAATTATCGATGAGCGTGGTGGTTATGCCGATCGCGTCACACTACGTCTGAACGTCGAAAACCCGAAACTGTGGAGCGCCGAAATCCCGAATCTCTATCGTGCGGTGGTTGAACTGCACACCGCCGACGGCACGCTGATTGAAGCAGAAGCCTGCGATGTCGGTTTCCGCGAGGTGCGGATTGAAAATGGTCTGCTGCTGCTGAACGGCAAGCCGTTGCTGATTCGAGGCGTTAACCGTCACGAGCATCATCCTCTGCATGGTCAGGTCATGGATGAGCAGACGATGGTGCAGGATATCCTGCTGATGAAGCAGAACAACTTTAACGCCGTGCGCTGTTCGCATTATCCGAACCATCCGCTGTGGTACACGCTGTGCGACCGCTACGGCCTGTATGTGGTGGATGAAGCCAATATTGAAACCCACGGCATGGTGCCAATGAATCGTCTGACCGATGATCCGCGCTGGCTACCGGCGATGAGCGAACGCGTAACGCGAATGGTGCAGCGCGATCGTAATCACCCGAGTGTGATCATCTGGTCGCTGGGGAATGAATCAGGCCACGGCGCTAATCACGACGCGCTGTATCGCTGGATCAAATCTGTCGATCCTTCCCGCCCGGTGCAGTATGAAGGCGGCGGAGCCGACACCACGGCCACCGATATTATTTGCCCGATGTACGCGCGCGTGGATGAAGACCAGCCCTTCCCGGCTGTGCCGAAATGGTCCATCAAAAAATGGCTTTCGCTACCTGGAGAGACGCGCCCGCTGATCCTTTGCGAATACGCCCACGCGATGGGTAACAGTCTTGGCGGTTTCGCTAAATACTGGCAGGCGTTTCGTCAGTATCCCCGTTTACAGGGCGGCTTCGTCTGGGACTGGGTGGATCAGTCGCTGATTAAATATGATGAAAACGGCAACCCGTGGTCGGCTTACGGCGGTGATTTTGGCGATACGCCGAACGATCGCCAGTTCTGTATGAACGGTCTGGTCTTTGCCGACCGCACGCCGCATCCAGCGCTGACGGAAGCAAAACACCAGCAGCAGTTTTTCCAGTTCCGTTTATCCGGGCAAACCATCGAAGTGACCAGCGAATACCTGTTCCGTCATAGCGATAACGAGCTCCTGCACTGGATGGTGGCGCTGGATGGTAAGCCGCTGGCAAGCGGTGAAGTGCCTCTGGATGTCGCTCCACAAGGTAAACAGTTGATTGAACTGCCTGAACTACCGCAGCCGGAGAGCGCCGGGCAACTCTGGCTCACAGTACGCGTAGTGCAACCGAACGCGACCGCATGGTCAGAAGCCGGGCACATCAGCGCCTGGCAGCAGTGGCGTCTGGCGGAAAACCTCAGTGTGACGCTCCCCGCCGCGTCCCACGCCATCCCGCATCTGACCACCAGCGAAATGGATTTTTGCATCGAGCTGGGTAATAAGCGTTGGCAATTTAACCGCCAGTCAGGCTTTCTTTCACAGATGTGGATTGGCGATAAAAAACAACTGCTGACGCCGCTGCGCGATCAGTTCACCCGTGCACCGCTGGATAACGACATTGGCGTAAGTGAAGCGACCCGCATTGACCCTAACGCCTGGGTCGAACGCTGGAAGGCGGCGGGCCATTACCAGGCCGAAGCAGCGTTGTTGCAGTGCACGGCAGATACACTTGCTGATGCGGTGCTGATTACGACCGCTCACGCGTGGCAGCATCAGGGGAAAACCTTATTTATCAGCCGGAAAACCTACCGGATTGATGGTAGTGGTCAAATGGCGATTACCGTTGATGTTGAAGTGGCGAGCGATACACCGCATCCGGCGCGGATTGGCCTGAACTGCCAGCTGGCGCAGGTAGCAGAGCGGGTAAACTGGCTCGGATTAGGGCCGCAAGAAAACTATCCCGACCGCCTTACTGCCGCCTGTTTTGACCGCTGGGATCTGCCATTGTCAGACATGTATACCCCGTACGTCTTCCCGAGCGAAAACGGTCTGCGCTGCGGGACGCGCGAATTGAATTATGGCCCACACCAGTGGCGCGGCGACTTCCAGTTCAACATCAGCCGCTACAGTCAACAGCAACTGATGGAAACCAGCCATCGCCATCTGCTGCACGCGGAAGAAGGCACATGGCTGAATATCGACGGTTTCCATATGGGGATTGGTGGCGACGACTCCTGGAGCCCGTCAGTATCGGCGGAATTCCAGCTGAGCGCCGGTCGCTACCATTACCAGTTGGTCTGGTGTCAAAAATAATAATAACCGGGCAGGCCATGTCTGCCCGTATTTCGCGTAAGGAAATCCATTATGTACTATTTAAAAAACACAAACTTTTGGATGTTCGGTTTATTCTTTTTCTTTTACTTTTTTATCATGGGAGCCTACTTCCCGTTTTTCCCGATTTGGCTACATGACATCAACCATATCAGCAAAAGTGATACGGGTATTATTTTTGCCGCTATTTCTCTGTTCTCGCTATTATTCCAACCGCTGTTTGGTCTGCTTTCTGACAAACTCGGGCTGCGCAAATACCTGCTGTGGATTATTACCGGCATGTTAGTGATGTTTGCGCCGTTCTTTATTTTTATCTTCGGGCCACTGTTACAATACAACATTTTAGTAGGATCGATTGTTGGTGGTATTTATCTAGGCTTTTGTTTTAACGCCGGTGCGCCAGCAGTAGAGGCATTTATTGAGAAAGTCAGCCGTCGCAGTAAT", "TGGCGCTGGGCGCAATGCGCGCCATTACCGAGTCCGGGCTGCGCGTTGGTGCGGATATCTCGGTAGTGGGATACGACGATACCGAAGACAGCTCATGTTATATCCCGCCGTTAACCACCATCAAACAGGATTTTCGCCTGCTGGGGCAAACCAGCGTGGACCGCTTGCTGCAACTCTCTCAGGGCCAGGCGGTGAAGGGCAATCAGCTGTTGCCCGTCTCACTGGTGAAAAGAAAAACCACCCTGGCGCCCAATACGCAAACCGCCTCTCCCCGCGCGTTGGCCGATTCATTAATGCAGCTGGCACGACAGGTTTCCCGACTGGAAAGCGGGCAGTGAGCGCAACGCAATTAATGTGAGTTAGCTCACTCATTAGGCACCCCAGGCTTTACACTTTATGCTTCCGGCTCGTATGTTGTGTGGAATTGTGAGCGGATAACAATTTCACACAGGAAACAGCTATGACCATGATTACGGATTCACTGGCCGTCGTTTTACAACGTCGTGACTGGGAAAACCCTGGCGTTACCCAACTTAATCGCCTTGCAGCACATCCCCCTTTCGCCAGCTGGCGTAATAGCGAAGAGGCCCGCACCGATCGCCCTTCCCAACAGTTGCGCAGCCTGAATGGCGAATGGCGCTTTGCCTGGTTTCCGGCACCAGAAGCGGTGCCGGAAAGCTGGCTGGAGTGCGATCTTCCTGAGGCCGATACTGTCGTCGTCCCCTCAAACTGGCAGATGCACGGTTACGATGCGCCCATCTACACCAACGTGACCTATCCCATTACGGTCAATCCGCCGTTTGTTCCCACGGAGAATCCGACGGGTTGTTACTCGCTCACATTTAATGTTGATGAAAGCTGGCTACAGGAAGGCCAGACGCGAATTATTTTTGATGGCGTTAACTCGGCGTTTCATCTGTGGTGCAACGGGCGCTGGGTCGGTTACGGCCAGGACAGTCGTTTGCCGTCTGAATTTGACCTGAGCGCATTTTTACGCGCCGGAGAAAACCGCCTCGCGGTGATGGTGCTGCGCTGGAGTGACGGCAGTTATCTGGAAGATCAGGATATGTGGCGGATGAGCGGCATTTTCCGTGACGTCTCGTTGCTGCATAAACCGACTACACAAATCAGCGATTTCCATGTTGCCACTCGCTTTAATGATGATTTCAGCCGCGCTGTACTGGAGGCTGAAGTTCAGATGTGCGGCGAGTTGCGTGACTACCTACGGGTAACAGTTTCTTTATGGCAGGGTGAAACGCAGGTCGCCAGCGGCACCGCGCCTTTCGGCGGTGAAATTATCGATGAGCGTGGTGGTTATGCCGATCGCGTCACACTACGTCTGAACGTCGAAAACCCGAAACTGTGGAGCGCCGAAATCCCGAATCTCTATCGTGCGGTGGTTGAACTGCACACCGCCGACGGCACGCTGATTGAAGCAGAAGCCTGCGATGTCGGTTTCCGCGAGGTGCGGATTGAAAATGGTCTGCTGCTGCTGAACGGCAAGCCGTTGCTGATTCGAGGCGTTAACCGTCACGAGCATCATCCTCTGCATGGTCAGGTCATGGATGAGCAGACGATGGTGCAGGATATCCTGCTGATGAAGCAGAACAACTTTAACGCCGTGCGCTGTTCGCATTATCCGAACCATCCGCTGTGGTACACGCTGTGCGACCGCTACGGCCTGTATGTGGTGGATGAAGCCAATATTGAAACCCACGGCATGGTGCCAATGAATCGTCTGACCGATGATCCGCGCTGGCTACCGGCGATGAGCGAACGCGTAACGCGAATGGTGCAGCGCGATCGTAATCACCCGAGTGTGATCATCTGGTCGCTGGGGAATGAATCAGGCCACGGCGCTAATCACGACGCGCTGTATCGCTGGATCAAATCTGTCGATCCTTCCCGCCCGGTGCAGTATGAAGGCGGCGGAGCCGACACCACGGCCACCGATATTATTTGCCCGATGTACGCGCGCGTGGATGAAGACCAGCCCTTCCCGGCTGTGCCGAAATGGTCCATCAAAAAATGGCTTTCGCTACCTGGAGAGACGCGCCCGCTGATCCTTTGCGAATACGCCCACGCGATGGGTAACAGTCTTGGCGGTTTCGCTAAATACTGGCAGGCGTTTCGTCAGTATCCCCGTTTACAGGGCGGCTTCGTCTGGGACTGGGTGGATCAGTCGCTGATTAAATATGATGAAAACGGCAACCCGTGGTCGGCTTACGGCGGTGATTTTGGCGATACGCCGAACGATCGCCAGTTCTGTATGAACGGTCTGGTCTTTGCCGACCGCACGCCGCATCCAGCGCTGACGGAAGCAAAACACCAGCAGCAGTTTTTCCAGTTCCGTTTATCCGGGCAAACCATCGAAGTGACCAGCGAATACCTGTTCCGTCATAGCGATAACGAGCTCCTGCACTGGATGGTGGCGCTGGATGGTAAGCCGCTGGCAAGCGGTGAAGTGCCTCTGGATGTCGCTCCACAAGGTAAACAGTTGATTGAACTGCCTGAACTACCGCAGCCGGAGAGCGCCGGGCAACTCTGGCTCACAGTACGCGTAGTGCAACCGAACGCGACCGCATGGTCAGAAGCCGGGCACATCAGCGCCTGGCAGCAGTGGCGTCTGGCGGAAAACCTCAGTGTGACGCTCCCCGCCGCGTCCCACGCCATCCCGCATCTGACCACCAGCGAAATGGATTTTTGCATCGAGCTGGGTAATAAGCGTTGGCAATTTAACCGCCAGTCAGGCTTTCTTTCACAGATGTGGATTGGCGATAAAAAACAACTGCTGACGCCGCTGCGCGATCAGTTCACCCGTGCACCGCTGGATAACGACATTGGCGTAAGTGAAGCGACCCGCATTGACCCTAACGCCTGGGTCGAACGCTGGAAGGCGGCGGGCCATTACCAGGCCGAAGCAGCGTTGTTGCAGTGCACGGCAGATACACTTGCTGATGCGGTGCTGATTACGACCGCTCACGCGTGGCAGCATCAGGGGAAAACCTTATTTATCAGCCGGAAAACCTACCGGATTGATGGTAGTGGTCAAATGGCGATTACCGTTGATGTTGAAGTGGCGAGCGATACACCGCATCCGGCGCGGATTGGCCTGAACTGCCAGCTGGCGCAGGTAGCAGAGCGGGTAAACTGGCTCGGATTAGGGCCGCAAGAAAACTATCCCGACCGCCTTACTGCCGCCTGTTTTGACCGCTGGGATCTGCCATTGTCAGACATGTATACCCCGTACGTCTTCCCGAGCGAAAACGGTCTGCGCTGCGGGACGCGCGAATTGAATTATGGCCCACACCAGTGGCGCGGCGACTTCCAGTTCAACATCAGCCGCTACAGTCAACAGCAACTGATGGAAACCAGCCATCGCCATCTGCTGCACGCGGAAGAAGGCACATGGCTGAATATCGACGGTTTCCATATGGGGATTGGTGGCGACGACTCCTGGAGCCCGTCAGTATCGGCGGAATTCCAGCTGAGCGCCGGTCGCTACCATTACCAGTTGGTCTGGTGTCAAAAATAATAATAACCGGGCAGGCCATGTCTGCCCGTATTTCGCGTAAGGAAATCCATTATGTACTATTTAAAAAACACAAACTTTTGGATGTTCGGTTTATTCTTTTTCTTTTACTTTTTTATCATGGGAGCCTACTTCCCGTTTTTCCCGATTTGGCTACATGACATCAACCATATCAGCAAAAGTGATACGGGTATTATTTTTGCCGCTATTTCTCTGTTCTCGCTATTATTCCAACCGCTGTTTGGTCTGCTTTCTGACAAACTCGGGCTGCGCAAATACCTGCTGTGGATTATTACCGGCATGTTAGTGATGTTTGCGCCGTTCTTTATTTTTATCTTCGGGCCACTGTTACAATACAACATTTTAGTAGGATCGATTGTTGGTGGTATTTATCTAGGCTTTTGTTTTAACGCCGGTGCGCCAGCAGTAGAGGCATTTATTGAGAAAGTCAGCCGTCGCAGTAAT"));
//        seqs.add(new dna("[Example] lacZ (beta-galactosidase, Lactobacillus delbruecki)", "AGCCCAGTCTCCGGACAATTAATGAACCTGGACATGGTTGACGACCCGGTCTTTGCCGACAAAAAGTTAGGCGACGGCTTTGCCCTGGTGCCAGCAGACGGTAAGGTCTACGCGCCATTTGCCGGTACTGTCCGCCAGCTGGCCAAGACCCGGCACTCGATCGTCCTGGAAAATGAACATGGGGTCTTGGTCTTGATTCACCTTGGCCTGGGCACGGCCAAATTAAACGGGACTGGCTTTGTCAGCTATGTTGAAGAGGGCAGCCAGGTAGAAGCCGGCCAGCAGATCCTGGAATTCTGGGACCCGGCGATCAAGCAGGCCAAGCTGGACGACACGGTAATCGTGACCGTCATCAACAGCGAAACTTTCGCAAATAGCCAGATGCTCTTGCCGATCGGCCACAGCGTCCAAGCCCTGGATGATGTATTCAAGTTAGAAGGGAAGAATTAGAAAATGAGCAATAAGTTAGTAAAAGAAAAAAGAGTTGACCAGGCAGACCTGGCCTGGCTGACTGACCCGGAAGTTTACGAAGTCAATACAATTCCCCCGCACTCCGACCATGAGTCCTTCCAAAGCCAGGAAGAACTGGAGGAGGGCAAGTCCAGTTTAGTGCAGTCCTTGGACGGGGACTGGCTGATTGACTACGCTGAAAACGGCCAGGGACCAGTCAACTTCTATGCAGAAGACTTTGACGATAGCAATTTTAAGTCAGTCAAAGTACCCGGCAACCTGGAACTGCAAGGCTTTGGCCAGCCCCAGTATGTCAACGTCCAATATCCATGGGACGGCAGTGAGGAGATTTTCCCGCCCCAAATTCCAAGCAAAAATCCGCTCGCTTCTTATGTCAGATACTTTGACCTGGATGAAGCTTTCTGGGACAAGGAAGTCAGCTTGAAGTTTGACGGGGCGGCAACAGCCATCTATGTCTGGCTGAACGGCCACTTCGTCGGCTACGGGGAAGACTCCTTTACCCCAAGCGAGTTTATGGTTACCAAGTTCCTCAAGAAAGAAAACAACCGCCTGGCAGTGGCTCTCTACAAGTATTCTTCCGCCTCCTGGCTGGAAGACCAGGACTTCTGGCGCATGTCTGGTTTGTTCAGATCAGTGACTCTTCAGGCCAAGCCGCGTCTGCACTTGGAGGACCTTAAGCTTACGGCCAGCTTGACCGATAACTACCAAAAAGGAAAGCTGGAAGTCGAAGCCAATATTGCCTACCGCTTGCCAAATGCCAGCTTTAAGCTGGAAGTGCGGGATAGTGAAGGTGACTTGGTTGCTGAAAAGCTGGGCCCAATCAGAAGCGAGCAGCTGGAATTCACTCTGGCTGATTTGCCAGTAGCTGCCTGGAGCGCGGAAAAGCCTAACCTTTACCAGGTCCGCCTGTATTTATACCAGGCAGGCAGCCTCTTAGAGGTTAGCCGGCAGGAAGTGGGTTTCCGCAACTTTGAACTAAAAGACGGGATTATGTACCTTAACGGCCAGCGGATCGTCTTCAAGGGGGCCAACCGGCACGAATTTGACAGTAAGTTGGGCCGGGCTATCACAGAAGAGGATATGATCTGGGATATCAAGACCATGAAGCGAAGCAACATCAATGCTGTCCGCTGCTCTCACTACCCGAACCAGTCCCTCTTTTACCGGCTCTGTGACAAGTACGGCCTTTACGTCATTGATGAAGCTAACCTGGAAAGCCACGGCACCTGGGAAAAAGTGGGGGGGCACGAAGATCCTAGCTTCAATGTTCCAGGCGATGACCAGCATTGGCTGGGAGCCAGCTTATCCCGGGTGAAGAACATGATGGCTCGGGACAAGAACCATGCTTCAATCCTGATCTGGTCTTTAGGCAATGAGTCTTACGCCGGCACTGTCTTTGCCCAAATGGCTGATTACGTCCGGAAGGCTGATCCGACCCGGGTTCAGCACTATGAAGGGGTGACCCACAACCGGAAGTTTGACGACGCCACCCAGATTGAAAGCCGGATGTATGCTCCGGCCAAGGTAATTGAAGAATACTTGACCAATAAACCAGCCAAGCCATTTATCTCAGTTGAATACGCTCACGCCATGGGCAACTCCGTCGGTGACCTGGCCGCCTACACGGCCCTGGAAAAATACCCCCACTACCAGGGCGGCTTCATCTGGGACTGGATTGACCAAGGACTGGAAAAAGACGGGCACCTGCTTTATGGGGGCGACTTCGATGACCGGCCAACCGACTATGAATTCTGCGGGAACGGCCTGGTCTTTGCTGACCGGACTGAATCGCCGAAACTGGCTAATGTCAAGGCCCTTTACGCCAACCTTAAGTTAGAAGTAAAAGATGGGCAGCTCTTCCTCAAAAACGACAATTTATTTACCAACAGCTCATCTTACTACTTCTTGACTAGTCTTTTGGTCGATGGCAAGTTGACCTACCAGAGCCGGCCTCTGACCTTTGGCCTGGAGCCTGGCGAATCCGGGACCTTTGCCCTGCCTTGGCCGGAAGTCGCTGATGAAAAAGGAGAGGTCGTCTACCGGGTAACGGCCCACTTAAAAGAAGACTTGCCTTGGGCGGATGAGGGCTTCACTGTGGCTGAAGCAGAAGAAGTAGCTCAAAAGCTGCCGGAATTTAAGCCGGAAGGGCGGCCAGATTTAGTTGATTCCGACTACAACCTAGGCCTGAAAGGAAATAACTTCCAAATTCTCTTCTCCAAGGTCAAGGGCTGGCCGGTTTCCCTCAAGTATGCCGGTAGGGAATACTTGAAGCGGCTGCCGGAATTTACCTTCTGGCGGGCCCTGACGGACAACGACCGGGGAGCTGGTTACGGCTATGATCTGGCCCGGTGGGAAAATGCCGGCAAGTATGCCCGCTTGAAAGACATCAGCTGCGAGGTCAAGGAAGACTCCGTTTTGGTCAAGACTGCCTTTACGTTGCCTGTCGCCTTAAAGGGTGATTTAACCGTGACCTATGAAGTCGATGGACGGGGCAAGATTGCTGTAACAGCTGACTTCCCAGGCGCGGAAGAAGCCGGTCTCTTGCCAGCCTTTGGCTTGAACCTAGCCCTGCCAAAAGAACTGACCGATTACCGCTACTATGGTCTGGGACCTAATGAGAGCTACCCAGACCGCTTGGAAGGTAATTACCTGGGCATCTACCAGGGAGCGGTAAAAAAGAACTTTAGCCCATACCTGCGTCCGCAGGAAACGGGCAACCGGAGCAAGGTTCGCTGGTACCAGCTCTTTGATGAAAAGGGCGGCTTGGAATTTACGGCCAATGGGGCAGACTTGAACTTGTCTGCTTTGCCATATTCTGCCGCCCAAATTGAAGCAGCGGACCACGCTTTTGAACTGACTAACAATTACACTTGGGTTAGAGCCTTAAGCGCCCAGATGGGGGTCGGCGGGGATGACTCCTGGGGGCAGAAGGTCCACCCGGAATTCTGCCTGGATGCTCAAAAAGCCCGCCAGCTCCGCCTGGTGATTCAGCCCCTTTTACTAAAATAAATGCTACAATTGACTTAACAGGATGAAATTTTAGTAAAAGCAAAGCGAGTGAGGAAGATGGCAACGATCAGAGAAGTGCCAAGGCAGCCGGCGTGTCGCTAGCGACGGTTTCCCGGGTCTTGAACTATGACCAGACCCTGTCAGTCAATGAGGCAACCCGGCAGAAGATATTTGAAACTGCTGAAGCCATGCACTACCATAAGAGCCGGAAGACCAGAAAGAGCAAGCAAAAGCGCCTGGCGATCTGCCTGTGGTGTGACCAAGACCAGGAGATCAAGGAGACCTCTATTACTATTCAATCAGAACCAGCGCGCAAGCATAGGCCAAGAAGCAGGGACTTGAAAGCCAGGTCATTTATCCGGCTGATCCTTTGCCCGATCCAGCTGCTTTAAGCGGGATCATCATGATTGGCTACCAGCAGTATTCGCCAGACCGCTTGAATGAAGTCAAAAAGT", "AGCCCAGTCTCCGGACAATTAATGAACCTGGACATGGTTGACGACCCGGTCTTTGCCGACAAAAAGTTAGGCGACGGCTTTGCCCTGGTGCCAGCAGACGGTAAGGTCTACGCGCCATTTGCCGGTACTGTCCGCCAGCTGGCCAAGACCCGGCACTCGATCGTCCTGGAAAATGAACATGGGGTCTTGGTCTTGATTCACCTTGGCCTGGGCACGGCCAAATTAAACGGGACTGGCTTTGTCAGCTATGTTGAAGAGGGCAGCCAGGTAGAAGCCGGCCAGCAGATCCTGGAATTCTGGGACCCGGCGATCAAGCAGGCCAAGCTGGACGACACGGTAATCGTGACCGTCATCAACAGCGAAACTTTCGCAAATAGCCAGATGCTCTTGCCGATCGGCCACAGCGTCCAAGCCCTGGATGATGTATTCAAGTTAGAAGGGAAGAATTAGAAAATGAGCAATAAGTTAGTAAAAGAAAAAAGAGTTGACCAGGCAGACCTGGCCTGGCTGACTGACCCGGAAGTTTACGAAGTCAATACAATTCCCCCGCACTCCGACCATGAGTCCTTCCAAAGCCAGGAAGAACTGGAGGAGGGCAAGTCCAGTTTAGTGCAGTCCTTGGACGGGGACTGGCTGATTGACTACGCTGAAAACGGCCAGGGACCAGTCAACTTCTATGCAGAAGACTTTGACGATAGCAATTTTAAGTCAGTCAAAGTACCCGGCAACCTGGAACTGCAAGGCTTTGGCCAGCCCCAGTATGTCAACGTCCAATATCCATGGGACGGCAGTGAGGAGATTTTCCCGCCCCAAATTCCAAGCAAAAATCCGCTCGCTTCTTATGTCAGATACTTTGACCTGGATGAAGCTTTCTGGGACAAGGAAGTCAGCTTGAAGTTTGACGGGGCGGCAACAGCCATCTATGTCTGGCTGAACGGCCACTTCGTCGGCTACGGGGAAGACTCCTTTACCCCAAGCGAGTTTATGGTTACCAAGTTCCTCAAGAAAGAAAACAACCGCCTGGCAGTGGCTCTCTACAAGTATTCTTCCGCCTCCTGGCTGGAAGACCAGGACTTCTGGCGCATGTCTGGTTTGTTCAGATCAGTGACTCTTCAGGCCAAGCCGCGTCTGCACTTGGAGGACCTTAAGCTTACGGCCAGCTTGACCGATAACTACCAAAAAGGAAAGCTGGAAGTCGAAGCCAATATTGCCTACCGCTTGCCAAATGCCAGCTTTAAGCTGGAAGTGCGGGATAGTGAAGGTGACTTGGTTGCTGAAAAGCTGGGCCCAATCAGAAGCGAGCAGCTGGAATTCACTCTGGCTGATTTGCCAGTAGCTGCCTGGAGCGCGGAAAAGCCTAACCTTTACCAGGTCCGCCTGTATTTATACCAGGCAGGCAGCCTCTTAGAGGTTAGCCGGCAGGAAGTGGGTTTCCGCAACTTTGAACTAAAAGACGGGATTATGTACCTTAACGGCCAGCGGATCGTCTTCAAGGGGGCCAACCGGCACGAATTTGACAGTAAGTTGGGCCGGGCTATCACAGAAGAGGATATGATCTGGGATATCAAGACCATGAAGCGAAGCAACATCAATGCTGTCCGCTGCTCTCACTACCCGAACCAGTCCCTCTTTTACCGGCTCTGTGACAAGTACGGCCTTTACGTCATTGATGAAGCTAACCTGGAAAGCCACGGCACCTGGGAAAAAGTGGGGGGGCACGAAGATCCTAGCTTCAATGTTCCAGGCGATGACCAGCATTGGCTGGGAGCCAGCTTATCCCGGGTGAAGAACATGATGGCTCGGGACAAGAACCATGCTTCAATCCTGATCTGGTCTTTAGGCAATGAGTCTTACGCCGGCACTGTCTTTGCCCAAATGGCTGATTACGTCCGGAAGGCTGATCCGACCCGGGTTCAGCACTATGAAGGGGTGACCCACAACCGGAAGTTTGACGACGCCACCCAGATTGAAAGCCGGATGTATGCTCCGGCCAAGGTAATTGAAGAATACTTGACCAATAAACCAGCCAAGCCATTTATCTCAGTTGAATACGCTCACGCCATGGGCAACTCCGTCGGTGACCTGGCCGCCTACACGGCCCTGGAAAAATACCCCCACTACCAGGGCGGCTTCATCTGGGACTGGATTGACCAAGGACTGGAAAAAGACGGGCACCTGCTTTATGGGGGCGACTTCGATGACCGGCCAACCGACTATGAATTCTGCGGGAACGGCCTGGTCTTTGCTGACCGGACTGAATCGCCGAAACTGGCTAATGTCAAGGCCCTTTACGCCAACCTTAAGTTAGAAGTAAAAGATGGGCAGCTCTTCCTCAAAAACGACAATTTATTTACCAACAGCTCATCTTACTACTTCTTGACTAGTCTTTTGGTCGATGGCAAGTTGACCTACCAGAGCCGGCCTCTGACCTTTGGCCTGGAGCCTGGCGAATCCGGGACCTTTGCCCTGCCTTGGCCGGAAGTCGCTGATGAAAAAGGAGAGGTCGTCTACCGGGTAACGGCCCACTTAAAAGAAGACTTGCCTTGGGCGGATGAGGGCTTCACTGTGGCTGAAGCAGAAGAAGTAGCTCAAAAGCTGCCGGAATTTAAGCCGGAAGGGCGGCCAGATTTAGTTGATTCCGACTACAACCTAGGCCTGAAAGGAAATAACTTCCAAATTCTCTTCTCCAAGGTCAAGGGCTGGCCGGTTTCCCTCAAGTATGCCGGTAGGGAATACTTGAAGCGGCTGCCGGAATTTACCTTCTGGCGGGCCCTGACGGACAACGACCGGGGAGCTGGTTACGGCTATGATCTGGCCCGGTGGGAAAATGCCGGCAAGTATGCCCGCTTGAAAGACATCAGCTGCGAGGTCAAGGAAGACTCCGTTTTGGTCAAGACTGCCTTTACGTTGCCTGTCGCCTTAAAGGGTGATTTAACCGTGACCTATGAAGTCGATGGACGGGGCAAGATTGCTGTAACAGCTGACTTCCCAGGCGCGGAAGAAGCCGGTCTCTTGCCAGCCTTTGGCTTGAACCTAGCCCTGCCAAAAGAACTGACCGATTACCGCTACTATGGTCTGGGACCTAATGAGAGCTACCCAGACCGCTTGGAAGGTAATTACCTGGGCATCTACCAGGGAGCGGTAAAAAAGAACTTTAGCCCATACCTGCGTCCGCAGGAAACGGGCAACCGGAGCAAGGTTCGCTGGTACCAGCTCTTTGATGAAAAGGGCGGCTTGGAATTTACGGCCAATGGGGCAGACTTGAACTTGTCTGCTTTGCCATATTCTGCCGCCCAAATTGAAGCAGCGGACCACGCTTTTGAACTGACTAACAATTACACTTGGGTTAGAGCCTTAAGCGCCCAGATGGGGGTCGGCGGGGATGACTCCTGGGGGCAGAAGGTCCACCCGGAATTCTGCCTGGATGCTCAAAAAGCCCGCCAGCTCCGCCTGGTGATTCAGCCCCTTTTACTAAAATAAATGCTACAATTGACTTAACAGGATGAAATTTTAGTAAAAGCAAAGCGAGTGAGGAAGATGGCAACGATCAGAGAAGTGCCAAGGCAGCCGGCGTGTCGCTAGCGACGGTTTCCCGGGTCTTGAACTATGACCAGACCCTGTCAGTCAATGAGGCAACCCGGCAGAAGATATTTGAAACTGCTGAAGCCATGCACTACCATAAGAGCCGGAAGACCAGAAAGAGCAAGCAAAAGCGCCTGGCGATCTGCCTGTGGTGTGACCAAGACCAGGAGATCAAGGAGACCTCTATTACTATTCAATCAGAACCAGCGCGCAAGCATAGGCCAAGAAGCAGGGACTTGAAAGCCAGGTCATTTATCCGGCTGATCCTTTGCCCGATCCAGCTGCTTTAAGCGGGATCATCATGATTGGCTACCAGCAGTATTCGCCAGACCGCTTGAATGAAGTCAAAAAGT"));
//        seqs.add(new aa("[Example] Polyubiquitin-B precursor (Homo Sapiens)", "MQIFVKTLTGKTITLEVEPSDTIENVKAKIQDKEGIPPDQQRLIFAGKQLEDGRTLSDYNIQKESTLHLVLRLRGGMQIFVKTLTGKTITLEVEPSDTIENVKAKIQDKEGIPPDQQRLIFAGKQLEDGRTLSDYNIQKESTLHLVLRLRGGMQIFVKTLTGKTITLEVEPSDTIENVKAKIQDKEGIPPDQQRLIFAGKQLEDGRTLSDYNIQKESTLHLVLRLRGGC", "MQIFVKTLTGKTITLEVEPSDTIENVKAKIQDKEGIPPDQQRLIFAGKQLEDGRTLSDYNIQKESTLHLVLRLRGGMQIFVKTLTGKTITLEVEPSDTIENVKAKIQDKEGIPPDQQRLIFAGKQLEDGRTLSDYNIQKESTLHLVLRLRGGMQIFVKTLTGKTITLEVEPSDTIENVKAKIQDKEGIPPDQQRLIFAGKQLEDGRTLSDYNIQKESTLHLVLRLRGGC"));
//        String json = gson.toJson(seqs);
        return ("[{\"pos\":3,\"name\":\"[Example] lacZ (beta-galactosidase, Escherichia coli)\",\"sequence\":\"TGGCGCTGGGCGCAATGCGCGCCATTACCGAGTCCGGGCTGCGCGTTGGTGCGGATATCTCGGTAGTGGGATACGACGATACCGAAGACAGCTCATGTTATATCCCGCCGTTAACCACCATCAAACAGGATTTTCGCCTGCTGGGGCAAACCAGCGTGGACCGCTTGCTGCAACTCTCTCAGGGCCAGGCGGTGAAGGGCAATCAGCTGTTGCCCGTCTCACTGGTGAAAAGAAAAACCACCCTGGCGCCCAATACGCAAACCGCCTCTCCCCGCGCGTTGGCCGATTCATTAATGCAGCTGGCACGACAGGTTTCCCGACTGGAAAGCGGGCAGTGAGCGCAACGCAATTAATGTGAGTTAGCTCACTCATTAGGCACCCCAGGCTTTACACTTTATGCTTCCGGCTCGTATGTTGTGTGGAATTGTGAGCGGATAACAATTTCACACAGGAAACAGCTATGACCATGATTACGGATTCACTGGCCGTCGTTTTACAACGTCGTGACTGGGAAAACCCTGGCGTTACCCAACTTAATCGCCTTGCAGCACATCCCCCTTTCGCCAGCTGGCGTAATAGCGAAGAGGCCCGCACCGATCGCCCTTCCCAACAGTTGCGCAGCCTGAATGGCGAATGGCGCTTTGCCTGGTTTCCGGCACCAGAAGCGGTGCCGGAAAGCTGGCTGGAGTGCGATCTTCCTGAGGCCGATACTGTCGTCGTCCCCTCAAACTGGCAGATGCACGGTTACGATGCGCCCATCTACACCAACGTGACCTATCCCATTACGGTCAATCCGCCGTTTGTTCCCACGGAGAATCCGACGGGTTGTTACTCGCTCACATTTAATGTTGATGAAAGCTGGCTACAGGAAGGCCAGACGCGAATTATTTTTGATGGCGTTAACTCGGCGTTTCATCTGTGGTGCAACGGGCGCTGGGTCGGTTACGGCCAGGACAGTCGTTTGCCGTCTGAATTTGACCTGAGCGCATTTTTACGCGCCGGAGAAAACCGCCTCGCGGTGATGGTGCTGCGCTGGAGTGACGGCAGTTATCTGGAAGATCAGGATATGTGGCGGATGAGCGGCATTTTCCGTGACGTCTCGTTGCTGCATAAACCGACTACACAAATCAGCGATTTCCATGTTGCCACTCGCTTTAATGATGATTTCAGCCGCGCTGTACTGGAGGCTGAAGTTCAGATGTGCGGCGAGTTGCGTGACTACCTACGGGTAACAGTTTCTTTATGGCAGGGTGAAACGCAGGTCGCCAGCGGCACCGCGCCTTTCGGCGGTGAAATTATCGATGAGCGTGGTGGTTATGCCGATCGCGTCACACTACGTCTGAACGTCGAAAACCCGAAACTGTGGAGCGCCGAAATCCCGAATCTCTATCGTGCGGTGGTTGAACTGCACACCGCCGACGGCACGCTGATTGAAGCAGAAGCCTGCGATGTCGGTTTCCGCGAGGTGCGGATTGAAAATGGTCTGCTGCTGCTGAACGGCAAGCCGTTGCTGATTCGAGGCGTTAACCGTCACGAGCATCATCCTCTGCATGGTCAGGTCATGGATGAGCAGACGATGGTGCAGGATATCCTGCTGATGAAGCAGAACAACTTTAACGCCGTGCGCTGTTCGCATTATCCGAACCATCCGCTGTGGTACACGCTGTGCGACCGCTACGGCCTGTATGTGGTGGATGAAGCCAATATTGAAACCCACGGCATGGTGCCAATGAATCGTCTGACCGATGATCCGCGCTGGCTACCGGCGATGAGCGAACGCGTAACGCGAATGGTGCAGCGCGATCGTAATCACCCGAGTGTGATCATCTGGTCGCTGGGGAATGAATCAGGCCACGGCGCTAATCACGACGCGCTGTATCGCTGGATCAAATCTGTCGATCCTTCCCGCCCGGTGCAGTATGAAGGCGGCGGAGCCGACACCACGGCCACCGATATTATTTGCCCGATGTACGCGCGCGTGGATGAAGACCAGCCCTTCCCGGCTGTGCCGAAATGGTCCATCAAAAAATGGCTTTCGCTACCTGGAGAGACGCGCCCGCTGATCCTTTGCGAATACGCCCACGCGATGGGTAACAGTCTTGGCGGTTTCGCTAAATACTGGCAGGCGTTTCGTCAGTATCCCCGTTTACAGGGCGGCTTCGTCTGGGACTGGGTGGATCAGTCGCTGATTAAATATGATGAAAACGGCAACCCGTGGTCGGCTTACGGCGGTGATTTTGGCGATACGCCGAACGATCGCCAGTTCTGTATGAACGGTCTGGTCTTTGCCGACCGCACGCCGCATCCAGCGCTGACGGAAGCAAAACACCAGCAGCAGTTTTTCCAGTTCCGTTTATCCGGGCAAACCATCGAAGTGACCAGCGAATACCTGTTCCGTCATAGCGATAACGAGCTCCTGCACTGGATGGTGGCGCTGGATGGTAAGCCGCTGGCAAGCGGTGAAGTGCCTCTGGATGTCGCTCCACAAGGTAAACAGTTGATTGAACTGCCTGAACTACCGCAGCCGGAGAGCGCCGGGCAACTCTGGCTCACAGTACGCGTAGTGCAACCGAACGCGACCGCATGGTCAGAAGCCGGGCACATCAGCGCCTGGCAGCAGTGGCGTCTGGCGGAAAACCTCAGTGTGACGCTCCCCGCCGCGTCCCACGCCATCCCGCATCTGACCACCAGCGAAATGGATTTTTGCATCGAGCTGGGTAATAAGCGTTGGCAATTTAACCGCCAGTCAGGCTTTCTTTCACAGATGTGGATTGGCGATAAAAAACAACTGCTGACGCCGCTGCGCGATCAGTTCACCCGTGCACCGCTGGATAACGACATTGGCGTAAGTGAAGCGACCCGCATTGACCCTAACGCCTGGGTCGAACGCTGGAAGGCGGCGGGCCATTACCAGGCCGAAGCAGCGTTGTTGCAGTGCACGGCAGATACACTTGCTGATGCGGTGCTGATTACGACCGCTCACGCGTGGCAGCATCAGGGGAAAACCTTATTTATCAGCCGGAAAACCTACCGGATTGATGGTAGTGGTCAAATGGCGATTACCGTTGATGTTGAAGTGGCGAGCGATACACCGCATCCGGCGCGGATTGGCCTGAACTGCCAGCTGGCGCAGGTAGCAGAGCGGGTAAACTGGCTCGGATTAGGGCCGCAAGAAAACTATCCCGACCGCCTTACTGCCGCCTGTTTTGACCGCTGGGATCTGCCATTGTCAGACATGTATACCCCGTACGTCTTCCCGAGCGAAAACGGTCTGCGCTGCGGGACGCGCGAATTGAATTATGGCCCACACCAGTGGCGCGGCGACTTCCAGTTCAACATCAGCCGCTACAGTCAACAGCAACTGATGGAAACCAGCCATCGCCATCTGCTGCACGCGGAAGAAGGCACATGGCTGAATATCGACGGTTTCCATATGGGGATTGGTGGCGACGACTCCTGGAGCCCGTCAGTATCGGCGGAATTCCAGCTGAGCGCCGGTCGCTACCATTACCAGTTGGTCTGGTGTCAAAAATAATAATAACCGGGCAGGCCATGTCTGCCCGTATTTCGCGTAAGGAAATCCATTATGTACTATTTAAAAAACACAAACTTTTGGATGTTCGGTTTATTCTTTTTCTTTTACTTTTTTATCATGGGAGCCTACTTCCCGTTTTTCCCGATTTGGCTACATGACATCAACCATATCAGCAAAAGTGATACGGGTATTATTTTTGCCGCTATTTCTCTGTTCTCGCTATTATTCCAACCGCTGTTTGGTCTGCTTTCTGACAAACTCGGGCTGCGCAAATACCTGCTGTGGATTATTACCGGCATGTTAGTGATGTTTGCGCCGTTCTTTATTTTTATCTTCGGGCCACTGTTACAATACAACATTTTAGTAGGATCGATTGTTGGTGGTATTTATCTAGGCTTTTGTTTTAACGCCGGTGCGCCAGCAGTAGAGGCATTTATTGAGAAAGTCAGCCGTCGCAGTAAT\",\"mark\":[],\"info\":\"DNA: 3997 bp\",\"type\":\"dna\"},{\"pos\":2,\"name\":\"[Example] lacZ (beta-galactosidase, Lactococcus lactis)\",\"sequence\":\"AAAATTGTTTTATTCAACCCCCTTTTTATGCTAATTTTGGTGGAAAAAATGTTCATTTTGGAACAGGGATTTATGCTAATTTTAATCTAACATTGGTTGACGATACAGATATTTTTGTAGGAAATCATGTCATGTTTGGACCAAATGTTACGATTGACACGGCGACACATCCTGTCTCGCTTGACTTACGTAAACGAGGGGCTCAATATAATAAAAAAGTTTATATTGAAGAAAATGTTTGGCTAGGTGCTGGTGTAATTGTGTTACCTGGTGTTAGAATTGGGAAAAATAGTGTGATTGGCGCAGGGAGTCTTGTAACTAAAGACATTCCAGATAATGTGGTTGCTTTTGGAACTCCTTGTATGGTTAAAAGAAAAATCAATGATTCTGACTTTAAAACTTATGATCATGGAAAAAAGATTGATTTAGATGAGTTCATCTGAAAGGAATGGCTATGATGACAATGATTGATGTACTAGAGCGTAAAGATTGGGAAAATCCAGTAGTTTCAAATTGGAATAGGTTGCCAATGCATACACCTATGGACTTTTTAGAAAAGCAATCACTGAATGGTCTTTGGAATTTTGATCATTTTTCTAGAATTTCAGATGTACCTAAAAATTGGTTAGAACTGACGGAGAGTAAAACGGAAATTATCGTTCCAAGTAATTGGCAAATAGAATTTAAGGATAAAAGCGATGTTCCAATTTATACAAATGTGACTTATCCTATTCCAATTCAGCCTCCTTATGTGCCAGAGGCTAACCCAGTTGGAGCTTATAGTCGCTATTTTGATATCACAAAAGAATGGCTTGAGAGCGGTCATGTTCACCTTACATTTGAAGGGGTTGGATCAGCTTTTCATTTTTGGTTGAATGGGGAATACGGAGGTTATTCAGAAGATAGCCGCTTGTCTGCTGAATTCGATATCAGCAACCTGGCCAAAGAAGGTCAAAATTGTTTAAAAGTTCTAGTTTTTCGTTGGTCAAAAGGCACCTATTTTGAAGATCAAGATATGTGGCGAATGTCAGGTATTTTTCGTTCGGTGAACTTACAATGGCTTCCAGATAACTACTTGTTAGACTTTTCTATAAAAACAGATTTGGATGAGGATTTAGATTTTGCAAATGTAAAACTTCAAGCATATGCTAAAAACATGGATGATGCTTGTTTAGAATTTAAGCTTTATGATGACGAACAATTAATTGGAGAGTGTCATGGTTTTGATGCAGAAATTGGAGTAGTCAATCCAAAATTATGGTCAGATGAAATTCCCTATCTTTATCGTTTAGAATTAACTTTAATGGACCGGAGTGGGGCGGTATTTCATAAAGAAACAAAAAAAATTGGTATTCGAAAAATTGCTATTGAAAAAGGACAGCTAAAAATAAACGGGAAAGCACTTCTTGTTCGTGGAGTGAATAAGCACGAATTTACCCCTGAGCATGGTTATGTCGTTTCTGAAGAAGTGATGATTAAAGACATCAAATTGATGAAAGAACATAATTTTAATGCGGTCCGCTGCTCTCATTATCCTAATGATTCACGCTGGTATGAATTGTGTGATGAATATGGATTGTATGTTATGGATGAAGCAAATATCGAAACGCATGGAATGACTCCGATGAATCGTTTGACAAATGATCCGACTTATTTACCATTAATGAGTGAACGTGTTACACGAATGGTTATGCGTGACCGTAATCATCCATCAATTATTATTTGGTCTCTTGGGAATGAGTCAGGTTATGGAAGTAACCATCAAGCTTTATATGATTGGTGTAAATCATTTGATTCTAGCCGCCCTGTTCATTATGAGGGGGGAGATGACGCAAGTAGAGGAGCAACAGATGCCACTGATATCATTTGTCCGATGTATGCTAGAGTAGATAGTCCAAGTATTAATGCGCCTTATTCATTAAAAACCTGGATGGGGGTAGCTGGAGAGAATAGACCACTAATTCTTTGTGAATATGCTCATGATATGGGGAATTCATTAGGAGGATTTGGGAAGTACTGGCAAGCTTTTCGAGAAATTGACCGATTGCAAGGTGGATTCATCTGGGATTGGGTGGATCAAGGTTTATTAAAAGATGGAAATTATGCTTATGGAGGTGACTTTGGGGATAAGCCAAATGATCGTCAGTTTAGCCTTAATGGTCTTGTTTTTCCAAATCGTCAAGCAAAACCAGCTCTTCGTGAAGCAAAATATTGGCAACAATATTATCAGTTTGAACTGGAGAAAACTCCACTAGGTCAAGTTTTTGCCTTTACAGTTACAAATGAGTATCTATTTCGAAGTACTGACAATGAAAAATTATGTTACCAACTGACCAATGGCTTAGAAGTATTATGGGAAAATGAGCTTATATTGAATATGCCTGCTGGAGGGTCTATGAGAATAGACCTGTCTGAGTTGCCTATTGATGGAACAGATAATTTATTTTTGAACATTCAAGTTAAAACAATTGAGAAATGTAATCTTCTTGAGTCTGATTTTGAAGTTGCTCATCAACAATTTGTTCTACAAGAAAAAATTAATTTTACTGACAGAATAGATAGTAATGAAGAAATTACACTTTTGGAGGATGAAGAGCTACTGACCGTACGATCAGCAAAACAGAAATTTATTTTTAATAAAAGCAATGGTAATCTCTCGCGCTGGCTTGATGAGAAAGGCAATGAAAAGTTACTGCATGAGCTCTCAGAACAATTTACAAGGGCTCCATTAGATAATGATATTGGTGTTAGTGAAGTTGAACATATTGATCCTAATGCTTGGTTAGAACGTTGGAAGGCTGTTGGCTTTTATGAGTTAAAAACGCTTTTGAAAAATATGATAATACAAGCAACAGAGAATGAAGTAATTATTTCTGTCCAAACAGACTATGAAGCAAAAGGAAAAATTGCATTTTCAACCATTCGAGAATATCATATTTTTAGAAACGGTGAACTTCTTTTAAAAGTTGATTTTAAAAGAAATATAGAGTTTCCAGAACCAGCTCGAATTGGCTTGAGTCTTCAACTAGCTGAAAAAGCAGAAAATGTTACATATTTTGGACTTGGCCCAGATGAAAATTATCCTGACCGAAGAGGGGCAAGTTTATTTGGTCAGTGGAATTTAAGGATTACTGATATGACAACCCCTTATATTTTTCCTAGTGAAAATGGGTTGAGGATGGAAACCAGAGAGCTAAATTATGGTCGTTTAAAAGTTCGGGCAATGGGTCAATCTTTTGCTTTTAATCTAAGTCCATATAGTCAAAACCAGCTTGCTAAAAAGGGACATTGGCATCTACTTGAAGAAGAAGCAGGAACATGGTTAAATATTGACGGATTCCATATGGGTGTAGGTGGAGATGATTCATGGAGTCCAAGTGTCGCTCAGGAATATTTATTGACAAAGGGAAATTATCATTATGAAGTTAGTTTTAAATTAACGTGATGATACAAATTTTCAAGAATTTGATATAATGTAGAGAAAATGGAGGTTCTTATGACGGTTTTAGTTCTTGGTGGAGCAGGATACGTGGGAAGTCACGCGGTAGATATGCTTCTTAAACGTGATTATGATGTGGCAGTGGTGGATAATTTAGTGACAGGCCACCGTGAATCTGTTCCAGCAAATGTACGCTTTTACGAGGGAGATGTGCGTGATCATGCTTTCTTAGCTAGTGTTTTTGAAAAAGAAAATATTGAAGGAATCATGCACTTCTGTGCTTACTCTTTAGTGGGTGAGTCAATGCAAAAACCTTTAATGTATTTTAATAATAATGTTGGTGGTGCTCAAGTAATTCTAGAAACGATGGAAGAATTCGGAGTAAAACATATTGTTTTCTCAAGTACAGCAGCTACATTTGGAATTCCAGAAAAAAGTCCAATTTCAGAAAAAACA\",\"mark\":[{\"name\":\"\",\"type\":1,\"start\":54,\"stop\":215},{\"name\":\"beta-galactosidase\",\"type\":102,\"start\":439,\"stop\":3444}],\"info\":\"DNA: 3895 bp\",\"type\":\"dna\"},{\"pos\":1,\"name\":\"[Example] Polyubiquitin-B precursor (Homo Sapiens)\",\"sequence\":\"MQIFVKTLTGKTITLEVEPSDTIENVKAKIQDKEGIPPDQQRLIFAGKQLEDGRTLSDYNIQKESTLHLVLRLRGGMQIFVKTLTGKTITLEVEPSDTIENVKAKIQDKEGIPPDQQRLIFAGKQLEDGRTLSDYNIQKESTLHLVLRLRGGMQIFVKTLTGKTITLEVEPSDTIENVKAKIQDKEGIPPDQQRLIFAGKQLEDGRTLSDYNIQKESTLHLVLRLRGGC\",\"mark\":[],\"info\":\"Protein: 229 aa\",\"type\":\"aa\"},{\"seqs\":[{\"pos\":\"-1\",\"name\":\"L. delbruecki\",\"sequence\":\"GSLLEVSRQEVGFRNFELKDGIMYLNGQRIVFKGANRHEFDSKLGRAITEEDMIWDIKTMKRSNINAVRCSHYPNQSLFYRLCDKYGLYVIDEANLESHGTWEKVGGHEDPSFNVPGDDQHWLGASLSRVKNMMARDKNHASILIWSLGNESYAGTVFAQMADYVRKADPTRVQHYEGVT-HNRKFDDATQIESRMYA\",\"mark\":[],\"info\":\"Protein: 198 aa\",\"type\":\"aa\"},{\"pos\":\"-1\",\"name\":\"L. lactis\",\"sequence\":\"GAVFHKETKKIGIRKIAIEKGQLKINGKALLVRGVNKHEFTPEHGYVVSEEVMIKDIKLMKEHNFNAVRCSHYPNDSRWYELCDEYGLYVMDEANIETHGM---------TPMNRLTNDPTYLPLMSERVTRMVMRDRNHPSIIIWSLGNESGYGSNHQALYDWCKSFDSSRPVHYEGGDDASRGATDATDIICPMYA\",\"mark\":[],\"info\":\"Protein: 198 aa\",\"type\":\"aa\"},{\"pos\":\"-1\",\"name\":\"E. coli\",\"sequence\":\"GTLIEAEACDVGFREVRIENGLLLLNGKPLLIRGVNRHEHHPLHGQVMDEQTMVQDILLMKQNNFNAVRCSHYPNHPLWYTLCDRYGLYVVDEANIETHGM---------VPMNRLTDDPRWLPAMSERVTRMVQRDRNHPSVIIWSLGNESGHGANHDALYRWIKSVDPSRPVQYEGGG----ADTTATDIICPMYA\",\"mark\":[],\"info\":\"Protein: 198 aa\",\"type\":\"aa\"}],\"info\":\"Alignment: 198<br><br>Line 1: L. delbruecki<br>Line 2: L. lactis<br>Line 3: E. coli\",\"name\":\"[Example] LacZ Alignment\",\"pos\":0,\"matches\":\"*:::  .  .:*:*:. ::.* : :**: ::..*.*.**. .  * .: *: *:.**  **  *:********** . :* *** *****:****:*:**           .:*   :*  :*    .**..*: **.**.*::********  *: .  :  : .. *.:*  :***          **:* . ***\",\"mark\":[],\"type\":\"alignmentProt\"}]");
    }

    private String multipleSequenceAlignment(String text, String seqType) {
        ArrayList<output> seqs = new ArrayList<>();

        if (seqType.equals("dna")) {
            dna[] S = gson.fromJson(text, dna[].class);

            //Limitation
            boolean limitationOK = true;
            if (S.length > 20) {
                seqs.add(new error("Currently the limit for this tool are 20 sequences with max length of 5kb"));
                limitationOK = false;
            } else {
                int maxLength = 0;
                for (dna s : S) {
                    if (s.sequence.length() > maxLength) {
                        maxLength = s.sequence.length();
                    }
                }
                if (maxLength > 5000) {
                    seqs.add(new error("Currently the limit for this tool are 20 sequences with max length of 5kb"));
                    limitationOK = false;
                }
            }

            if (!limitationOK) {
                return sendOutput(seqs);
            }

            try {
                Process process = new ProcessBuilder("timeout", "20s", "nice", "-5", softwareDir + "muscle", "-maxiters", "1", "-diags", "-clw").start(); //http://www.drive5.com/muscle/manual/fastest.html
                BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));
                BufferedReader error = new BufferedReader(new InputStreamReader(process.getErrorStream()));
                BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(process.getOutputStream()));

                for (int i = 0; i < S.length; i++) {
                    bw.write(">" + i);
                    bw.newLine();
                    bw.write(S[i].sequence);
                    bw.newLine();
                }
                bw.close();

                String line;
                String[] outputLine = new String[S.length];
                for (int i = 0; i < S.length; i++) {
                    outputLine[i] = "";
                }
                String conservedLine = "";

                int[] order = new int[S.length];
                int k = 0;
                boolean firstPass = true;
                int conservedpos = 0;
                while ((line = br.readLine()) != null) {
                    if (k == S.length) //conservation line
                    {
                        conservedLine = conservedLine.concat(line.substring(conservedpos));
                        k++;
                        continue;
                    }
                    if (line.isEmpty() || line.startsWith("MUSCLE")) {
                        if (firstPass && k == S.length + 1) {
                            firstPass = false;
                        }
                        k = 0;
                        continue;
                    }
                    String[] b = line.split("\\s+", 2);
                    if (firstPass) {
                        order[k] = Integer.decode(b[0]);
                        conservedpos = line.indexOf(b[1]);
                    }
                    outputLine[k] = outputLine[k].concat(b[1]);
                    k++;
                }

                while ((line = error.readLine()) != null) {
                    System.err.println("muscle: " + line);
                }

                for (int i = 0; i < S.length; i++) {
                    if (outputLine[i].isEmpty()) {
                        seqs.add(new error("Error occured; No response from MUSCLE"));
                        return sendOutput(seqs);
                    }
                }

                ArrayList<dna> alignedSeqs = new ArrayList<>();
                for (int i = 0; i < S.length; i++) {
                    dna newDNA = new dna(S[order[i]].name, outputLine[i]);
                    alignedSeqs.add(newDNA);
                }

                String info = "Alignment: " + alignedSeqs.get(0).sequence.length() + " columns<br>";
                for (int i = 0; i < alignedSeqs.size(); i++) {
                    info += "<br>Line " + (i + 1) + ": " + alignedSeqs.get(i).name;
                }

                if (process.waitFor() == 124) { //timeout command
                    seqs.add(new error("Timeout: Try again later or try to again less or shorter sequences"));
                    return sendOutput(seqs);
                }

                seqs.add(new alignmentDNA("DNA alignment", alignedSeqs, S[S.length - 1].pos, info, conservedLine));

            } catch (IOException e) {
                seqs.add(new error("Error occured"));
                return sendOutput(seqs);
            } catch (InterruptedException e) {
                seqs.add(new error("InterruptedException"));
                return sendOutput(seqs);
            }
        } else if (seqType.equals("aa")) {
            aa[] S = gson.fromJson(text, aa[].class);
            try {
                Process process = new ProcessBuilder("timeout", "20s", "nice", "-5", softwareDir + "muscle", "-maxiters", "1", "-diags", "-sv", "-distance1", "kbit20_3", "-clw").start(); //http://www.drive5.com/muscle/manual/fastest.html
                BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));
                BufferedReader error = new BufferedReader(new InputStreamReader(process.getErrorStream()));
                BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(process.getOutputStream()));

                boolean hasStops = false;
                for (int i = 0; i < S.length; i++) {
                    String noStop = S[i].sequence.replace("*", "");
                    if (noStop.length() == 0) {
                        seqs.add(new error("A Protein sequence consists solely of stops"));
                        return sendOutput(seqs);
                    }
                    if (noStop.length() < S[i].sequence.length()) {
                        hasStops = true;
                    }
                    bw.write(">" + i);
                    bw.newLine();
                    bw.write(noStop);
                    bw.newLine();
                }
                bw.close();

                String line;
                String[] outputLine = new String[S.length];
                for (int i = 0; i < S.length; i++) {
                    outputLine[i] = "";
                }
                String conservedLine = "";

                int[] order = new int[S.length];
                int k = 0;
                boolean firstPass = true;
                int conservedpos = 0;
                while ((line = br.readLine()) != null) {
                    System.out.println(line);
                    if (k == S.length) //conservation line
                    {
                        conservedLine = conservedLine.concat(line.substring(conservedpos));
                        k++;
                        continue;
                    }
                    if (line.isEmpty() || line.startsWith("MUSCLE")) {
                        if (firstPass && k == S.length + 1) {
                            firstPass = false;
                        }
                        k = 0;
                        continue;
                    }
                    String[] b = line.split("\\s+", 2);
                    if (firstPass) {
                        order[k] = Integer.decode(b[0]);
                        conservedpos = line.indexOf(b[1]);
                    }
                    outputLine[k] = outputLine[k].concat(b[1]);
                    k++;
                }

                while ((line = error.readLine()) != null) {
                    System.err.println("muscle: " + line);
                }

                for (int i = 0; i < S.length; i++) {
                    if (outputLine[i].isEmpty()) {
                        seqs.add(new error("Error occured; No response from MUSCLE"));
                        return sendOutput(seqs);
                    }
                }

                ArrayList<aa> alignedSeqs = new ArrayList<>();
                for (int i = 0; i < S.length; i++) {
                    aa newDNA = new aa(S[order[i]].name, outputLine[i]);
                    alignedSeqs.add(newDNA);
                }

                String info = "Alignment: " + alignedSeqs.get(0).sequence.length() + " columns<br>";
                for (int i = 0; i < alignedSeqs.size(); i++) {
                    info += "<br>Line " + (i + 1) + ": " + alignedSeqs.get(i).name;
                }
                if (hasStops) {
                    info += "<br><font color='red'>Stops have been removed</font>";
                }

                if (process.waitFor() == 124) { //timeout command
                    seqs.add(new error("Timeout: Try again later or try with less or shorter sequences"));
                    return sendOutput(seqs);
                }

                seqs.add(new alignmentProt("Protein alignment", alignedSeqs, S[S.length - 1].pos, info, conservedLine));
            } catch (IOException e) {
                System.err.println(e);
                seqs.add(new error("Error occured"));
                return sendOutput(seqs);
            } catch (InterruptedException e) {
                seqs.add(new error("InterruptedException"));
                return sendOutput(seqs);
            }
        }
        return sendOutput(seqs);
    }

    private String findSequenceDNA(String text, String bothStrands, String searchFor) {
        boolean bothStrandsBool = bothStrands.equalsIgnoreCase("true");
        ArrayList<output> seqs = new ArrayList<>();
        ArrayList<findMarks> foundMarks = new ArrayList<>();
        if (text.isEmpty() || searchFor.isEmpty()) {
            seqs.add(new error("Error occured"));
        } else {
            dna[] S = gson.fromJson(text, dna[].class);
            alignmentDNA[] T = gson.fromJson(text, alignmentDNA[].class);
            if (S == null || S.length == 0) {
                seqs.add(new error("Error occured"));
            } else {
                searchFor = convertDNASequence(searchFor);
                if (searchFor.isEmpty()) {
                    seqs.add(new error("Error occured"));
                } else {
                    SequenceDNA q = new SequenceDNA(searchFor, false);

                    if (bothStrandsBool && SequenceTools.reverseComplement(q, true, true).equals(q)) {
                        bothStrandsBool = false;
                    }

                    for (int k = 0; k < S.length; k++) {
                        if (S[k].type == OutputType.dna) {
                            dna t = S[k];
                            SequenceDNA a = new SequenceDNA(t.sequence, false);
                            int[] upper = SequenceTools.findSequenceUpperStrand(q, a);
                            int[] lower = null;
                            if (bothStrandsBool) {
                                lower = SequenceTools.findSequenceLowerStrand(q, a);
                            }

                            if (upper.length > 0 || (bothStrandsBool && lower.length > 0)) {
                                ArrayList<mark> marks = t.mark;
                                for (int i : upper) {
                                    foundMarks.add(new findMarks(Integer.decode(t.pos), i, i + q.getLength() - 1));
                                }

                                if (bothStrandsBool) {
                                    for (int i : lower) {
                                        foundMarks.add(new findMarks(Integer.decode(t.pos), i, i + q.getLength() - 1));
                                    }
                                }
                            }
                        } else if (S[k].type == OutputType.alignmentDNA) {
                            alignmentDNA t = T[k];
                            for (int l = 0; l < t.seqs.size(); l++) {
                                dna c = t.seqs.get(l);
                                SequenceDNA orig = new SequenceDNA(c.sequence, false);
                                SequenceDNA noGaps = (new SequenceDNA(c.sequence, false));
                                noGaps.killGaps();

                                int[] upper = SequenceTools.findSequenceUpperStrand(q, noGaps);
                                int[] lower = null;
                                if (bothStrandsBool) {
                                    lower = SequenceTools.findSequenceLowerStrand(q, noGaps);
                                }

                                if (upper.length > 0 || (bothStrandsBool && lower.length > 0)) {
                                    for (int i : upper) {
                                        findMarks found = new findMarks(Integer.decode(t.pos), i, i + q.getLength() - 1, l);
                                        byte[] d = orig.getByteArray();
                                        int gapCount = 0;
                                        int s = 0;
                                        for (; s < found.start + 1; s++) {
                                            if (d[s] == Nucleotide.__) {
                                                gapCount++;
                                                found.start++;
                                            }
                                        }
                                        found.end += gapCount;
                                        for (; s < found.end + 1; s++) {
                                            if (d[s] == Nucleotide.__) {
                                                found.end++;
                                            }
                                        }
                                        foundMarks.add(found);
                                    }

                                    if (bothStrandsBool) {
                                        for (int i : lower) {
                                            findMarks found = new findMarks(Integer.decode(t.pos), i, i + q.getLength() - 1, l);
                                            byte[] d = orig.getByteArray();
                                            int gapCount = 0;
                                            int s = 0;
                                            for (; s < found.start + 1; s++) {
                                                if (d[s] == Nucleotide.__) {
                                                    gapCount++;
                                                    found.start++;
                                                }
                                            }
                                            found.end += gapCount;
                                            for (; s < found.end + 1; s++) {
                                                if (d[s] == Nucleotide.__) {
                                                    found.end++;
                                                }
                                            }
                                            foundMarks.add(found);
                                        }
                                    }
                                }//is alignmentDNA
                            } //loop ber seq des alignments
                        } //fertig is alignment
                    } //fertig loop ber sequenzen
                }
            }
        }
        if (seqs.isEmpty()) {
            return sendOutput2(foundMarks);
        } else {
            return sendOutput(seqs);
        }
    }

    public class findMarks {
        int entry;
        int start;
        int end;
        int row = -1;

        public findMarks(int entry, int start, int end) {
            this.entry = entry;
            this.start = start;
            this.end = end;
        }

        public findMarks(int entry, int start, int end, int row) {
            this.entry = entry;
            this.start = start;
            this.end = end;
            this.row = row;
        }
    }

    private String findSequenceAA(String text, String searchFor) {
        ArrayList<output> seqs = new ArrayList<>();
        ArrayList<findMarks> foundMarks = new ArrayList<>();
        if (text.isEmpty() || searchFor.isEmpty()) {
            seqs.add(new error("Error occured"));
        } else {
            aa[] S = gson.fromJson(text, aa[].class);
            alignmentProt[] T = gson.fromJson(text, alignmentProt[].class);
            if (S == null || S.length == 0) {
                seqs.add(new error("Error occured"));
            } else {
                searchFor = convertAASequence(searchFor);
                if (searchFor.isEmpty()) {
                    seqs.add(new error("Error occured"));
                } else {
                    SequenceAA q = new SequenceAA(searchFor);
                    for (int k = 0; k < S.length; k++) {
                        if (S[k].type == OutputType.aa) {
                            aa s = S[k];
                            SequenceAA a = new SequenceAA(s.sequence);
                            int[] upper = SequenceTools.findSequenceProtein(q, a);

                            if (upper.length > 0) {
                                ArrayList<mark> marks = s.mark;
                                for (int i : upper) {
                                    foundMarks.add(new findMarks(Integer.decode(s.pos), i, i + q.getLength() - 1));
                                }
                            }
                        } else if (S[k].type == OutputType.alignmentProt) {
                            alignmentProt t = T[k];
                            for (int l = 0; l < t.seqs.size(); l++) {
                                aa c = t.seqs.get(l);
                                SequenceAA orig = new SequenceAA(c.sequence);
                                SequenceAA noGaps = orig.killGaps();

                                int[] upper = SequenceTools.findSequenceProtein(q, noGaps);

                                for (int i : upper) {
                                    findMarks found = new findMarks(Integer.decode(t.pos), i, i + q.getLength() - 1, l);
                                    byte[] d = orig.getByteArray();
                                    int gapCount = 0;
                                    int s = 0;
                                    for (; s < found.start + 1; s++) {
                                        if (d[s] == Aminoacids.__) {
                                            gapCount++;
                                            found.start++;
                                        }
                                    }
                                    found.end += gapCount;
                                    for (; s < found.end + 1; s++) {
                                        if (d[s] == Aminoacids.__) {
                                            found.end++;
                                        }
                                    }
                                    foundMarks.add(found);
                                }
                            } //loop ber seq des alignments
                        }
                    } //fertig loop ber sequenzen
                }
            }
        }
        if (seqs.isEmpty()) {
            return sendOutput2(foundMarks);
        } else {
            return sendOutput(seqs);
        }
    }

    private String highlightSequence(String text, String pos, String start, String end, String color, String annotation) {
        ArrayList<output> seqs = new ArrayList<>();
        if (text.isEmpty()) {
            seqs.add(new error("Error occured"));
        } else {
            dna S = gson.fromJson(text, dna.class);
            if (S == null || S.name.isEmpty() || S.mark == null) {
                seqs.add(new error("Error occured"));
            } else {
                int startInt = Integer.parseInt(start);
                int stopInt = Integer.parseInt(end);
                ArrayList<mark> marks = null;
                if (color.equals("removeColor")) {
                    marks = removeMark(S.mark, startInt, stopInt, true, false);
                } else if (color.equals("removeAnnotation")) {
                    marks = removeMark(S.mark, startInt, stopInt, false, true);
                } else {
                    int col = Integer.decode(color);
                    if (col < 100) { //only marking, no annotation
                        if (startInt > stopInt) {
                            int b = stopInt;
                            stopInt = startInt;
                            startInt = b;
                        }
                        marks = addMark(S.mark, startInt, stopInt, col);
                    } else { //annotation
                        if (annotation.length() > 100) {
                            annotation = annotation.substring(0, 97) + "...";
                        }
                        marks = addMarkAnnotation(S.mark, startInt, stopInt, annotation, col);
                    }
                }

                if (S.type == OutputType.dna) {
                    seqs.add(new dna(S.name, S.sequence, marks, pos));
                } else if (S.type == OutputType.aa) {
                    seqs.add(new aa(S.name, S.sequence, marks, pos));
                } else if (S.type == OutputType.alignmentDNA) {
                    alignmentDNA A = gson.fromJson(text, alignmentDNA.class);
                    seqs.add(new alignmentDNA(A.name, A.seqs, A.pos, A.info, A.matches, marks));
                } else if (S.type == OutputType.alignmentProt) {
                    alignmentProt A = gson.fromJson(text, alignmentProt.class);
                    seqs.add(new alignmentProt(A.name, A.seqs, A.pos, A.info, A.matches, marks));
                }
            }
        }
        return sendOutput(seqs);
    }

    private String addCustomText(String text, String title, String pos) {
        ArrayList<output> seqs = new ArrayList<>();
        seqs.add(new customText(title, "", text, pos));
        return sendOutput(seqs);
    }

    private String getSubsequence(String text, String title, String reverse, String noMarks, String start, String end) {
        ArrayList<output> seqs = new ArrayList<>();
        boolean reverseBool = (reverse != null && reverse.equalsIgnoreCase("true"));
        boolean noMarksBool = (noMarks != null && noMarks.equalsIgnoreCase("true"));
        if (text.isEmpty()) {
            seqs.add(new error("Error occured"));
        } else {
            dna S = gson.fromJson(text, dna.class);
            if (S.type == OutputType.aa || S.type == OutputType.dna) { //is Sequence
                if (S.sequence.isEmpty() || S.name.isEmpty() || S.mark == null) {
                    seqs.add(new error("Error occured"));
                } else {
                    String pos = S.pos;
                    int startInt = Integer.parseInt(start);
                    int stopInt = Integer.parseInt(end);

                    if (startInt > stopInt) {
                        int b = stopInt;
                        stopInt = startInt;
                        startInt = b;
                    }
                    if (startInt < 0) {
                        startInt = 0;
                    }
                    ArrayList<mark> newMarks = markSubsequence(S.mark, startInt, stopInt);
                    String subseq = S.sequence.substring(startInt, stopInt + 1);

                    if (S.type == outputTypes.OutputType.dna) {
                        if (reverseBool) {
                            subseq = (SequenceTools.reverseComplement(new SequenceDNA(subseq, false), true, true)).toString();
                            newMarks = markReverse(newMarks, subseq.length());
                        }
                        if (title == null) {
                            title = S.name + " [Subsequence " + (startInt + 1) + "-" + (stopInt + 1) + "]" + (reverseBool ? "[RevComp]" : "");
                        }
                        seqs.add(new dna(title, subseq, (noMarksBool ? (new ArrayList<mark>()) : newMarks), pos));
                    } else if (S.type == outputTypes.OutputType.aa) {
                        if (reverseBool) {
                            throw new UnsupportedOperationException("Reverse Complement for Amino Acids");
                        }
                        if (title == null) {
                            title = S.name + " [Subsequence " + (startInt + 1) + "-" + (stopInt + 1) + "]";
                        }
                        seqs.add(new aa(title, subseq, (noMarksBool ? (new ArrayList<mark>()) : newMarks), pos));
                    }
                }
            } else if (S.type == OutputType.alignmentDNA || S.type == OutputType.alignmentProt) { //is Alignment
                if (reverseBool) {
                    throw new UnsupportedOperationException("Reverse Complement for Alignments");
                }
                alignmentProt A = gson.fromJson(text, alignmentProt.class);
                boolean isDNA = (S.type == OutputType.alignmentDNA);
                if (A.seqs == null || A.matches.isEmpty()) {
                    seqs.add(new error("Error occured"));
                } else {
                    int startInt = Integer.parseInt(start);
                    int stopInt = Integer.parseInt(end);

                    if (startInt > stopInt) {
                        int b = stopInt;
                        stopInt = startInt;
                        startInt = b;
                    }

                    if (startInt < 0) {
                        startInt = 0;
                    }

                    ArrayList<mark> alignMarks = markSubsequence(S.mark, startInt, stopInt);

                    ArrayList<aa> subsequenceAA = new ArrayList<>();
                    ArrayList<dna> subsequenceDNA = new ArrayList<>();
                    for (aa seq : A.seqs) {
                        ArrayList<mark> newMarks = markSubsequence(seq.mark, startInt, stopInt);
                        String subseq = seq.sequence.substring(startInt, stopInt + 1);
                        if (isDNA) {
                            subsequenceDNA.add(new dna(seq.name, subseq, newMarks));
                        } else {
                            subsequenceAA.add(new aa(seq.name, subseq, newMarks));
                        }
                    }

                    if (isDNA) {
                        String info = "Alignment: " + subsequenceDNA.get(0).sequence.length() + "<br>";
                        for (int i = 0; i < subsequenceDNA.size(); i++) {
                            info += "<br>Line " + (i + 1) + ": " + subsequenceDNA.get(i).name;
                        }
                        if (title == null) {
                            title = A.name + " [Subcolumns " + (startInt + 1) + "-" + (stopInt + 1) + "]";
                        }
                        seqs.add(new alignmentDNA(title, subsequenceDNA, A.pos, info, A.matches.substring(startInt, stopInt + 1), alignMarks));
                    } else if (A.type == OutputType.alignmentProt) {
                        String info = "Alignment: " + subsequenceAA.get(0).sequence.length() + "<br>";
                        for (int i = 0; i < subsequenceAA.size(); i++) {
                            info += "<br>Line " + (i + 1) + ": " + subsequenceAA.get(i).name;
                        }
                        if (title == null) {
                            title = A.name + " [Subcolumns " + (startInt + 1) + "-" + (stopInt + 1) + "]";
                        }
                        seqs.add(new alignmentProt(title, subsequenceAA, A.pos, info, A.matches.substring(startInt, stopInt + 1), alignMarks));
                    }
                }
            }
        }
        return sendOutput(seqs);
    }

    private String revComp(String text, String type, String pos) {
        ArrayList<output> seqs = new ArrayList<>();
        if (text.isEmpty()) {
            seqs.add(new error("Error occured"));
        } else {
            dna S = gson.fromJson(text, dna.class);
            if (S == null || S.sequence.isEmpty() || S.name.isEmpty() || S.mark == null) {
                seqs.add(new error("Error occured"));
            } else {
                boolean reverse;
                boolean complement;
                switch (type) {
                    case "RevComp":
                        reverse = true;
                        complement = true;
                        break;
                    case "Rev":
                        reverse = true;
                        complement = false;
                        break;
                    default:
                        reverse = false;
                        complement = true;
                        break;
                }
                SequenceDNA Ss = new SequenceDNA(S.sequence, false);
                String outSeq = (SequenceTools.reverseComplement(Ss, reverse, complement)).toString();
                ArrayList<mark> marks = S.mark;
                if (reverse) {
                    marks = markReverse(marks, Ss.getLength());
                }
                seqs.add(new dna(S.name + " [" + type + "]", outSeq, marks, pos));
            }
        }
        return sendOutput(seqs);
    }

    private String alignPw(String text, String seqType, String alignmentType) {
        ArrayList<output> seqs = new ArrayList<>();
        if (text.isEmpty() || seqType.isEmpty() || alignmentType.isEmpty()) {
            seqs.add(new error("Error occured"));
        } else {
            boolean isDNA = !seqType.equalsIgnoreCase("aa");
            if (isDNA) {
                dna[] S = gson.fromJson(text, dna[].class);
                if (S == null || S.length == 0) {
                    seqs.add(new error("Error occured"));
                } else {
                    Alignment align = null;
                    SequenceDNA a = new SequenceDNA(S[0].sequence, false);
                    SequenceDNA b = new SequenceDNA(S[1].sequence, false);
                    //int alignLength = 0;

                    switch (alignmentType) {
                        case "CFE":
                            align = AlignmentTools.align(a, b, sms_dna, AlignmentTools.CFE);
                            //alignLength = (align.endPosA - align.startPosA) + 1;
                            break;
                        case "Global":
                            align = AlignmentTools.align(a, b, sms_dna, AlignmentTools.Global);
                            //alignLength = (align.endPosA - align.startPosA > align.endPosB - align.startPosB ? align.endPosA - align.startPosA : align.endPosB - align.startPosB) + 1;
                            break;
                        case "Local":
                            align = AlignmentTools.align(a, b, sms_dna, AlignmentTools.Local);
                            //alignLength = (align.endPosA - align.startPosA) + 1;
                            break;
                        default:
                            seqs.add(new error("Error occured: Couldn't convert AlignmentType"));
                            return sendOutput(seqs);
                    }

                    String aS = (new SequenceDNA(align.a, false)).toString();
                    String bS = (new SequenceDNA(align.b, false)).toString();

                    boolean[] matches = align.getMatching();

                    ArrayList<dna> alignedSeqs = new ArrayList<>();
                    alignedSeqs.add(new dna(S[0].name, aS));
                    alignedSeqs.add(new dna(S[1].name, bS));

                    char[] m = new char[aS.length()];

                    for (int i = 0; i < aS.length(); i++) {
                        if (matches[i]) {
                            m[i] = '*';
                        } else {
                            m[i] = ' ';
                        }
                    }

                    String info = "Alignment: " + aS.length() + " columns<br><br>";
                    if (alignmentType.equals("Local")) {
                        info += "Top: " + S[0].name + " [" + (align.startPosA + 1) + "-" + (align.endPosA + 1) + "]<br>";
                        info += "Bottom: " + S[1].name + " [" + (align.startPosB + 1) + "-" + (align.endPosB + 1) + "]";
                    } else {
                        info += "Top: " + S[0].name + "<br>";
                        info += "Bottom: " + S[1].name;
                    }

                    seqs.add(new alignmentDNA("Pairwise " + alignmentType + " Alignment", alignedSeqs, S[0].pos, info, new String(m)));

                }
            } else //is AA
            {
                aa[] S = gson.fromJson(text, aa[].class);
                if (S == null || S.length == 0) {
                    seqs.add(new error("Error occured"));
                } else {
                    Alignment align = null;
                    boolean hasStops = false;
                    String noStopA = S[0].sequence.replace("*", "");
                    String noStopB = S[1].sequence.replace("*", "");
                    if (noStopA.length() == 0 || noStopB.length() == 0) {
                        seqs.add(new error("A Protein sequence consists solely of stops"));
                        return sendOutput(seqs);
                    }
                    if (noStopA.length() < S[0].sequence.length() || noStopB.length() < S[1].sequence.length()) {
                        hasStops = true;
                    }

                    SequenceAA a = new SequenceAA(noStopA);
                    SequenceAA b = new SequenceAA(noStopB);
                    //int alignLength = 0;

                    switch (alignmentType) {
                        case "CFE":
                            align = AlignmentTools.align(a, b, sms_aa, AlignmentTools.CFE);
                            //alignLength = (align.endPosA - align.startPosA) + 1;
                            break;
                        case "Global":
                            align = AlignmentTools.align(a, b, sms_aa, AlignmentTools.Global);
                            //alignLength = (align.endPosA - align.startPosA > align.endPosB - align.startPosB ? align.endPosA - align.startPosA : align.endPosB - align.startPosB) + 1;
                            break;
                        case "Local":
                            align = AlignmentTools.align(a, b, sms_aa, AlignmentTools.Local);
                            //alignLength = (align.endPosA - align.startPosA) + 1;
                            break;
                        default:
                            seqs.add(new error("Error occured: Couldn't convert AlignmentType"));
                            return sendOutput(seqs);
                    }

                    String aS = (new SequenceAA(align.a)).toString();
                    String bS = (new SequenceAA(align.b)).toString();

                    boolean[] matches = align.getMatching();

                    ArrayList<aa> alignedSeqs = new ArrayList<>();
                    alignedSeqs.add(new aa(S[0].name, aS));
                    alignedSeqs.add(new aa(S[1].name, bS));

                    char[] m = new char[aS.length()];

                    for (int i = 0; i < aS.length(); i++) {
                        if (matches[i]) {
                            m[i] = '*';
                        } else {
                            m[i] = ' ';
                        }
                    }

                    String info = "Alignment: " + aS.length() + " columns<br><br>";

                    if (alignmentType.equals("Local")) {
                        info += "Top: " + S[0].name + " [" + (align.startPosA + 1) + "-" + (align.endPosA + 1) + "]<br>";
                        info += "Bottom: " + S[1].name + " [" + (align.startPosB + 1) + "-" + (align.endPosB + 1) + "]";
                    } else {
                        info += "Top: " + S[0].name + "<br>";
                        info += "Bottom: " + S[1].name;
                    }
                    if (hasStops) {
                        info += "<br><font color='red'>Any stops have been removed</font>";
                    }

                    seqs.add(new alignmentProt("Pairwise " + alignmentType + " Alignment", alignedSeqs, S[0].pos, info, new String(m)));
                }
            }
            return sendOutput(seqs);
        }
        return "Error";
    }

    public String getDatafromDB(String key) {
        ArrayList<output> seqs = new ArrayList<>();
        if (key == null || key.isEmpty()) {
            seqs.add(new error("Error occured"));
        } else {
            List<ProjectEntity> projectEntities = projectEntityRepository.findByLink(key);

            if (projectEntities.isEmpty())
                seqs.add(new error("The project could not be found<br> Key: " + key));
            else {
                ProjectEntity out = projectEntities.get(0);
                out.setUploadDate(new Date(System.currentTimeMillis()));
                projectEntityRepository.save(out);
                return out.getText();
            }
        }
        return sendOutput(seqs);
    }

    private String primer3(MultiValueMap<String, String> allRequestParams) {
        ArrayList<output> seqs = new ArrayList<>();

        String sequence = allRequestParams.getFirst("text");
        String target_str = allRequestParams.getFirst("target");
        List<String> exclusion_str = allRequestParams.get("exclusion[]");
        if (exclusion_str == null) {
            exclusion_str = allRequestParams.get("exclusion");
        }
        String product_min_str = allRequestParams.getFirst("product_min");
        String product_max_str = allRequestParams.getFirst("product_max");
        String min_size_str = allRequestParams.getFirst("min_size");
        String opt_size_str = allRequestParams.getFirst("opt_size");
        String max_size_str = allRequestParams.getFirst("max_size");
        String min_tm_str = allRequestParams.getFirst("min_tm");
        String opt_tm_str = allRequestParams.getFirst("opt_tm");
        String max_tm_str = allRequestParams.getFirst("max_tm");
        String min_gc_str = allRequestParams.getFirst("min_gc");
        String max_gc_str = allRequestParams.getFirst("max_gc");
        String salt_monovalent_str = allRequestParams.getFirst("salt_monovalent");
        String dna_conc_str = allRequestParams.getFirst("dna_conc");

        String doInternal_str = allRequestParams.getFirst("doInternal");
        boolean doInternal = doInternal_str != null && doInternal_str.equalsIgnoreCase("true");
        String internal_min_size_str = allRequestParams.getFirst("internal_min_size");
        String internal_opt_size_str = allRequestParams.getFirst("internal_opt_size");
        String internal_max_size_str = allRequestParams.getFirst("internal_max_size");
        String internal_min_tm_str = allRequestParams.getFirst("internal_min_tm");
        String internal_opt_tm_str = allRequestParams.getFirst("internal_opt_tm");
        String internal_max_tm_str = allRequestParams.getFirst("internal_max_tm");
        String internal_min_gc_str = allRequestParams.getFirst("internal_min_gc");
        String internal_max_gc_str = allRequestParams.getFirst("internal_max_gc");
        String internal_salt_monovalent_str = allRequestParams.getFirst("internal_salt_monovalent");
        String internal_dna_conc_str = allRequestParams.getFirst("internal_dna_conc");

        String forceLeft_str = allRequestParams.getFirst("doForceLeft");
        boolean doForceLeft = forceLeft_str != null && forceLeft_str.equalsIgnoreCase("true");
        String forceLeftPos_str = allRequestParams.getFirst("forceLeftPosition");
        String forceRight_str = allRequestParams.getFirst("doForceRight");
        boolean doForceRight = forceRight_str != null && forceRight_str.equalsIgnoreCase("true");
        String forceRightPos_str = allRequestParams.getFirst("forceRightPosition");

        if (sequence == null) {
            seqs.add(new error("Missing parameters"));
            return sendOutput(seqs);
        }
        SequenceDNA seq = (new SequenceDNA(sequence, false));
        seq.killGaps();
        if (seq.getLength() > 20000) {
            seqs.add(new error("Sequence is longer than 20000bp"));
            return sendOutput(seqs);
        }
        if (seq.getLength() < 20) {
            seqs.add(new error("Sequence is shorter than 20bp"));
            return sendOutput(seqs);
        }
        seq.updateNucleotideCount();

        if (target_str == null || exclusion_str == null || product_min_str == null || product_max_str == null || min_size_str == null || opt_size_str == null || max_size_str == null || min_tm_str == null || opt_tm_str == null || max_tm_str == null || salt_monovalent_str == null || dna_conc_str == null || min_gc_str == null || max_gc_str == null) {
            System.out.println(target_str);
            System.out.println(exclusion_str);
            System.out.println(product_min_str);
            System.out.println(product_max_str);
            System.out.println(min_size_str);
            System.out.println(opt_size_str);
            System.out.println(max_size_str);

            System.out.println(min_tm_str);
            System.out.println(opt_tm_str);
            System.out.println(max_tm_str);
            System.out.println(salt_monovalent_str);
            System.out.println(dna_conc_str);
            System.out.println(min_gc_str);
            System.out.println(max_gc_str);

            seqs.add(new error("Missing parameters"));
            return sendOutput(seqs);
        }
        if (doInternal && (internal_min_size_str == null || internal_opt_size_str == null || internal_max_size_str == null || internal_min_tm_str == null || internal_opt_tm_str == null || internal_max_tm_str == null || internal_salt_monovalent_str == null || internal_dna_conc_str == null || internal_min_gc_str == null || internal_max_gc_str == null)) {
            System.out.println(internal_min_size_str);
            System.out.println(internal_opt_size_str);
            System.out.println(internal_max_size_str);

            System.out.println(internal_min_tm_str);
            System.out.println(internal_opt_tm_str);
            System.out.println(internal_max_tm_str);
            System.out.println(internal_salt_monovalent_str);
            System.out.println(internal_dna_conc_str);
            System.out.println(internal_min_gc_str);
            System.out.println(internal_max_gc_str);
            seqs.add(new error("Missing parameters"));
            return sendOutput(seqs);
        }

        if (doForceRight && forceRightPos_str == null) {
            System.out.println(forceRightPos_str);
            seqs.add(new error("Missing parameters"));
            return sendOutput(seqs);
        }

        if (doForceLeft && forceLeftPos_str == null) {
            System.out.println(forceLeftPos_str);
            seqs.add(new error("Missing parameters"));
            return sendOutput(seqs);
        }

        int target_start = -1;
        int target_end = -1;
        int[] exclusion_start;
        int[] exclusion_end;
        int product_min;
        int product_max;
        int min_size;
        int opt_size;
        int max_size;
        double min_tm;
        double opt_tm;
        double max_tm;
        int min_gc;
        int max_gc;
        double salt_monovalent;
        double dna_conc;
        int internal_min_size = -1;
        int internal_opt_size = -1;
        int internal_max_size = -1;
        double internal_min_tm = -1;
        double internal_opt_tm = -1;
        double internal_max_tm = -1;
        int internal_min_gc = -1;
        int internal_max_gc = -1;
        double internal_salt_monovalent = -1;
        double internal_dna_conc = -1;
        int forceLeftPosition = -1;
        int forceRightPosition = -1;
        boolean noTarget = false;
        try {
            if ("null".equals(target_str)) {
                noTarget = true;
            } else {
                int seperator = target_str.indexOf("-");
                if (seperator < 0) {
                    seqs.add(new error("Error formatting Target"));
                    return sendOutput(seqs);
                }

                target_start = Integer.parseInt(target_str.substring(0, seperator));
                target_end = Integer.parseInt(target_str.substring(seperator + 1));
            }

            if ("keine".equals(exclusion_str.get(0))) {
                exclusion_start = null;
                exclusion_end = null;
            } else {
                exclusion_start = new int[exclusion_str.size()];
                exclusion_end = new int[exclusion_str.size()];
                for (int i = 0; i < exclusion_str.size(); i++) {
                    int seperator = exclusion_str.get(i).indexOf("-");
                    if (seperator < 0) {
                        seqs.add(new error("Error formating Exclusion"));
                        return sendOutput(seqs);
                    }
                    exclusion_start[i] = Integer.parseInt(exclusion_str.get(i).substring(0, seperator));
                    exclusion_end[i] = Integer.parseInt(exclusion_str.get(i).substring(seperator + 1));
                }
            }

            product_min = Integer.parseInt(product_min_str);
            product_max = Integer.parseInt(product_max_str);
            min_size = Integer.parseInt(min_size_str);
            opt_size = Integer.parseInt(opt_size_str);
            max_size = Integer.parseInt(max_size_str);
            min_tm = Double.parseDouble(min_tm_str);
            opt_tm = Double.parseDouble(opt_tm_str);
            max_tm = Double.parseDouble(max_tm_str);
            min_gc = Integer.parseInt(min_gc_str);
            max_gc = Integer.parseInt(max_gc_str);
            salt_monovalent = Double.parseDouble(salt_monovalent_str);
            dna_conc = Double.parseDouble(dna_conc_str);
            if (doInternal) {
                internal_min_size = Integer.parseInt(internal_min_size_str);
                internal_opt_size = Integer.parseInt(internal_opt_size_str);
                internal_max_size = Integer.parseInt(internal_max_size_str);
                internal_min_tm = Double.parseDouble(internal_min_tm_str);
                internal_opt_tm = Double.parseDouble(internal_opt_tm_str);
                internal_max_tm = Double.parseDouble(internal_max_tm_str);
                internal_min_gc = Integer.parseInt(internal_min_gc_str);
                internal_max_gc = Integer.parseInt(internal_max_gc_str);
                internal_salt_monovalent = Double.parseDouble(internal_salt_monovalent_str);
                internal_dna_conc = Double.parseDouble(internal_dna_conc_str);
            }
            if (doForceRight) {
                forceRightPosition = Integer.parseInt(forceRightPos_str);
            }
            if (doForceLeft) {
                forceLeftPosition = Integer.parseInt(forceLeftPos_str);
            }
        } catch (NumberFormatException ex) {
            seqs.add(new error("Can't convert parameter to number"));
            return sendOutput(seqs);
        }

        try {
            Process process = new ProcessBuilder("timeout", "20s", "nice", "-5", softwareDir + "primer3").start();
            BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));
            BufferedReader error = new BufferedReader(new InputStreamReader(process.getErrorStream()));
            BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(process.getOutputStream()));

            bw.write("SEQUENCE_TEMPLATE=" + seq);
            bw.newLine();
            if (!noTarget) {
                bw.write("SEQUENCE_TARGET=" + (target_start) + "," + (target_end - target_start + 1));
                bw.newLine();
            }
            bw.write("PRIMER_PRODUCT_SIZE_RANGE=" + product_min + "-" + product_max);
            bw.newLine();
            if (exclusion_start != null) {
                bw.write("SEQUENCE_EXCLUDED_REGION=");
                for (int i = 0; i < exclusion_start.length; i++) {
                    bw.write((exclusion_start[i]) + "," + (exclusion_end[i] - exclusion_start[i] + 1) + " ");
                }
                bw.newLine();
            }
            if (doForceLeft) {
                bw.write("SEQUENCE_FORCE_LEFT_START=" + forceLeftPosition);
                bw.newLine();
            }
            if (doForceRight) {
                bw.write("SEQUENCE_FORCE_RIGHT_START=" + forceRightPosition);
                bw.newLine();
            }

            bw.write("PRIMER_TASK=generic");
            bw.newLine();
            bw.write("PRIMER_PICK_LEFT_PRIMER=1");
            bw.newLine();
            bw.write("PRIMER_PICK_RIGHT_PRIMER=1");
            bw.newLine();
            bw.write("PRIMER_MIN_SIZE=" + min_size);
            bw.newLine();
            bw.write("PRIMER_OPT_SIZE=" + opt_size);
            bw.newLine();
            bw.write("PRIMER_MAX_SIZE=" + max_size);
            bw.newLine();
            bw.write("PRIMER_MIN_TM=" + min_tm);
            bw.newLine();
            bw.write("PRIMER_OPT_TM=" + opt_tm);
            bw.newLine();
            bw.write("PRIMER_MAX_TM=" + max_tm);
            bw.newLine();
            bw.write("PRIMER_MIN_GC=" + min_gc);
            bw.newLine();
            bw.write("PRIMER_MAX_GC=" + max_gc);
            bw.newLine();
            bw.write("PRIMER_SALT_MONOVALENT=" + salt_monovalent);
            bw.newLine();
            bw.write("PRIMER_DNA_CONC=" + dna_conc);
            bw.newLine();

            if (doInternal) {
                bw.write("PRIMER_PICK_INTERNAL_OLIGO=1");
                bw.newLine();
                bw.write("PRIMER_INTERNAL_MIN_SIZE=" + internal_min_size);
                bw.newLine();
                bw.write("PRIMER_INTERNAL_OPT_SIZE=" + internal_opt_size);
                bw.newLine();
                bw.write("PRIMER_INTERNAL_MAX_SIZE=" + internal_max_size);
                bw.newLine();
                bw.write("PRIMER_INTERNAL_MIN_TM=" + internal_min_tm);
                bw.newLine();
                bw.write("PRIMER_INTERNAL_OPT_TM=" + internal_opt_tm);
                bw.newLine();
                bw.write("PRIMER_INTERNAL_MAX_TM=" + internal_max_tm);
                bw.newLine();
                bw.write("PRIMER_INTERNAL_MIN_GC=" + internal_min_gc);
                bw.newLine();
                bw.write("PRIMER_INTERNAL_MAX_GC=" + internal_max_gc);
                bw.newLine();
                bw.write("PRIMER_INTERNAL_SALT_MONOVALENT=" + internal_salt_monovalent);
                bw.newLine();
                bw.write("PRIMER_INTERNAL_DNA_CONC=" + internal_dna_conc);
                bw.newLine();
                if (exclusion_start != null) {
                    bw.write("SEQUENCE_INTERNAL_EXCLUDED_REGION=");
                    for (int i = 0; i < exclusion_start.length; i++) {
                        bw.write((exclusion_start[i]) + "," + (exclusion_end[i] - exclusion_start[i] + 1) + " ");
                    }
                    bw.newLine();
                }
            } else {
                bw.write("PRIMER_PICK_INTERNAL_OLIGO=0");
                bw.newLine();
            }

            bw.write("PRIMER_THERMODYNAMIC_PARAMETERS_PATH=" + softwareDir + "primer3-2.3.6/src/primer3_config/");
            bw.newLine();
            bw.write("PRIMER_EXPLAIN_FLAG=1");
            bw.newLine();
            bw.write("=");
            bw.newLine();
            bw.close();

            ArrayList<String> outputs = new ArrayList<>();
            String line;
            while ((line = br.readLine()) != null) {
                outputs.add(line);
            }

            while ((line = error.readLine()) != null) {
                System.err.println("Primer3: " + line);
            }

            if (process.waitFor() == 124) {
                seqs.add(new error("Timeout: Try again later or try to again less or shorter sequences"));
                return sendOutput(seqs);
            }

            primer3 primerOutput = new primer3();
            String errorString = findPrimer3Output("PRIMER_ERROR=", outputs);
            if (errorString == null) {
                int primerPairs = Integer.parseInt(findPrimer3Output("PRIMER_PAIR_NUM_RETURNED=", outputs));
                if (primerPairs == 0) {
                    primerOutput.explanation = "Left Primer: " + findPrimer3Output("PRIMER_LEFT_EXPLAIN=", outputs) + "<br>";
                    primerOutput.explanation += "Right Primer: " + findPrimer3Output("PRIMER_RIGHT_EXPLAIN=", outputs) + "<br>";
                    if (doInternal) {
                        primerOutput.explanation += "Probe: " + findPrimer3Output("PRIMER_INTERNAL_EXPLAIN=", outputs) + "<br>";
                    }
                    primerOutput.explanation += "Primer Pairs: " + findPrimer3Output("PRIMER_PAIR_EXPLAIN=", outputs);
                } else {
                    for (int i = 0; i < primerPairs; i++) {
                        String left_seq = findPrimer3Output("PRIMER_LEFT_" + i + "_SEQUENCE=", outputs);
                        String right_seq = findPrimer3Output("PRIMER_RIGHT_" + i + "_SEQUENCE=", outputs);
                        String primer_left_str = findPrimer3Output("PRIMER_LEFT_" + i + "=", outputs);
                        int left_pos = Integer.parseInt(primer_left_str.substring(0, primer_left_str.indexOf(",")));
                        String primer_right_str = findPrimer3Output("PRIMER_RIGHT_" + i + "=", outputs);
                        int right_pos = Integer.parseInt(primer_right_str.substring(0, primer_right_str.indexOf(",")));
                        float left_tm = Float.parseFloat(findPrimer3Output("PRIMER_LEFT_" + i + "_TM=", outputs));
                        float right_tm = Float.parseFloat(findPrimer3Output("PRIMER_RIGHT_" + i + "_TM=", outputs));
                        int left_gc = (int) Float.parseFloat(findPrimer3Output("PRIMER_LEFT_" + i + "_GC_PERCENT=", outputs));
                        int right_gc = (int) Float.parseFloat(findPrimer3Output("PRIMER_RIGHT_" + i + "_GC_PERCENT=", outputs));
                        int product_size = Integer.parseInt(findPrimer3Output("PRIMER_PAIR_" + i + "_PRODUCT_SIZE=", outputs));

                        String internal_seq = "";
                        int internal_pos = -1;
                        float internal_tm = -1;
                        int internal_gc = -1;
                        if (doInternal) {
                            internal_seq = findPrimer3Output("PRIMER_INTERNAL_" + i + "_SEQUENCE=", outputs);
                            String primer_internal_str = findPrimer3Output("PRIMER_INTERNAL_" + i + "=", outputs);
                            internal_pos = Integer.parseInt(primer_internal_str.substring(0, primer_internal_str.indexOf(",")));
                            internal_tm = Float.parseFloat(findPrimer3Output("PRIMER_INTERNAL_" + i + "_TM=", outputs));
                            internal_gc = (int) Float.parseFloat(findPrimer3Output("PRIMER_INTERNAL_" + i + "_GC_PERCENT=", outputs));
                        }

                        if (doInternal) {
                            primerOutput.primerPairs.add(new primer3.primerPair(left_seq, right_seq, internal_seq, left_pos, right_pos, internal_pos, left_tm, right_tm, internal_tm, left_gc, right_gc, internal_gc, product_size));
                        } else {
                            primerOutput.primerPairs.add(new primer3.primerPair(left_seq, right_seq, left_pos, right_pos, left_tm, right_tm, left_gc, right_gc, product_size));
                        }
                    } //cycle primers
                }
            } else {
                primerOutput.error = errorString;
            }
            seqs.add(primerOutput);
            return sendOutput(seqs);

        } catch (IOException e) {
            seqs.add(new error("Error occured"));
            return sendOutput(seqs);
        } catch (InterruptedException e) {
            seqs.add(new error("InterruptedException"));
            return sendOutput(seqs);
        }
    }

    private String findPrimer3Output(String find, ArrayList<String> lines) {
        for (String s : lines) {
            if (s.startsWith(find)) {
                return s.substring(find.length());
            }
        }
        return null;
    }

    private String saveToDB(String text) {
        ArrayList<output> seqs = new ArrayList<>();

        if (text == null || text.isEmpty()) {
            seqs.add(new error("Error occured"));
        } else {
            //Limitation
            if (text.length() > 5000000) {
                seqs.add(new error("Currently the limit to store projects is 5MB"));
                return sendOutput(seqs);
            }
            String key = null;

            for (int i = 0; i < 10; i++) { //Make sure to create a unique string
                key = generateDbKey();
                if (projectEntityRepository.findByLink(key).isEmpty())
                    break;
            }

            if (key == null) {
                seqs.add(new error("Could not generate new Key"));
            } else {
                ProjectEntity projectEntity = new ProjectEntity();
                projectEntity.setText(text);
                projectEntity.setLink(key);
                projectEntity.setUploadDate(new Date(System.currentTimeMillis()));
                projectEntityRepository.save(projectEntity);
                seqs.add(new shareInfo(httpAddress + "/share=d" + key));
            }
        }
        return sendOutput(seqs);
    }

    private String alignmentConsensus(String text) {
        ArrayList<output> seqs = new ArrayList<>();
        if (text.isEmpty()) {
            seqs.add(new error("Error occured"));
        } else {
            output S = gson.fromJson(text, output.class);
            if (S == null) {
                seqs.add(new error("Error occured"));
            } else {
                if (S.type == outputTypes.OutputType.alignmentDNA) { //DNA alignment
                    alignmentDNA A = gson.fromJson(text, alignmentDNA.class);
                    int n = A.seqs.size();
                    String[] align = new String[n];
                    for (int i = 0; i < n; i++) {
                        align[i] = A.seqs.get(i).sequence;
                    }
                    String consensus = getConsensus(align, false);
                    seqs.add(new dna(A.name + " [Consensus]", consensus));
                } else if (S.type == outputTypes.OutputType.alignmentProt) { //AA alignment
                    alignmentProt A = gson.fromJson(text, alignmentProt.class);
                    int n = A.seqs.size();
                    String[] align = new String[n];
                    for (int i = 0; i < n; i++) {
                        align[i] = A.seqs.get(i).sequence;
                    }
                    String consensus = getConsensus(align, true);
                    seqs.add(new aa(A.name + " [Consensus]", consensus));
                } else {
                    seqs.add(new error("Error occured"));
                }
            }
        }
        return sendOutput(seqs);
    }

    private String alignmentTree(String text) {
        ArrayList<output> seqs = new ArrayList<>();
        if (text.isEmpty()) {
            seqs.add(new error("Error occured"));
        } else {
            output S = gson.fromJson(text, output.class);
            if (S == null) {
                seqs.add(new error("Error occured"));
            } else {
                ArrayList<String> fastaAlignment = new ArrayList<>();
                String title = "";
                if (S.type == outputTypes.OutputType.alignmentDNA) { //DNA alignment
                    alignmentDNA A = gson.fromJson(text, alignmentDNA.class);
                    title = A.name;
                    int n = A.seqs.size();
                    for (int i = 0; i < n; i++) {
                        fastaAlignment.add(">" + A.seqs.get(i).name);
                        fastaAlignment.add(A.seqs.get(i).sequence);
                    }
                } else if (S.type == outputTypes.OutputType.alignmentProt) { //AA alignment
                    alignmentProt A = gson.fromJson(text, alignmentProt.class);
                    title = A.name;
                    int n = A.seqs.size();
                    for (int i = 0; i < n; i++) {
                        fastaAlignment.add(">" + A.seqs.get(i).name);
                        fastaAlignment.add(A.seqs.get(i).sequence);
                    }
                } else {
                    seqs.add(new error("Error occured"));
                    return sendOutput(seqs);
                }

                try {
                    Process process = new ProcessBuilder("timeout", "20s", "nice", "-5", softwareDir + "muscle", "-maketree").start(); //http://www.drive5.com/muscle/manual/fastest.html
                    BufferedReader br = new BufferedReader(new InputStreamReader(process.getInputStream()));
                    BufferedReader error = new BufferedReader(new InputStreamReader(process.getErrorStream()));
                    BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(process.getOutputStream()));

                    for (int i = 0; i < fastaAlignment.size(); i++) {
                        bw.write(fastaAlignment.get(i));
                        bw.newLine();
                    }
                    bw.close();

                    String tree = "";
                    String line;
                    while ((line = br.readLine()) != null) {
                        tree += line;
                    }
                    ArrayList<String> treeSVG = phylTree.makeSVG(tree, 800, 20);

                    String svg = "";
                    for (String s : treeSVG) {
                        svg += s;
                    }
                    svg += "<p>Newick Format:<br><code>" + tree + "</code></p>";

                    while ((line = error.readLine()) != null) {
                        System.err.println("muscle: " + line);
                    }

                    if (process.waitFor() == 124) {
                        seqs.add(new error("Timeout: Try again later or try to again less or shorter sequences"));
                        return sendOutput(seqs);
                    }

                    seqs.add(new customText(title + " [Tree]", "", svg));
                } catch (IOException e) {
                    seqs.add(new error("Error occured"));
                    return sendOutput(seqs);
                } catch (phylTree.FormattingException e) {
                    seqs.add(new error(e.descr));
                    return sendOutput(seqs);
                } catch (InterruptedException e) {
                    seqs.add(new error("InterruptedException"));
                    return sendOutput(seqs);
                }
            }
        }
        return sendOutput(seqs);
    }

    private String alignmentLogo(String text) {
        ArrayList<output> seqs = new ArrayList<>();
        if (text.isEmpty()) {
            seqs.add(new error("Error occured"));
        } else {
            output S = gson.fromJson(text, output.class);
            if (S == null) {
                seqs.add(new error("Error occured"));
            } else {
                ArrayList<String> fastaAlignment = new ArrayList<>();
                String title = "";
                boolean isDNA = true;
                if (S.type == outputTypes.OutputType.alignmentDNA) { //DNA alignment
                    alignmentDNA A = gson.fromJson(text, alignmentDNA.class);

                    //Limitation
                    if (A.seqs.get(0).sequence.length() > 10000) {
                        seqs.add(new error("Currently the limit for this tool is an alignment with maximal 1000 columns"));
                        return sendOutput(seqs);
                    }

                    title = A.name;
                    int n = A.seqs.size();
                    for (int i = 0; i < n; i++) {
                        fastaAlignment.add(">" + A.seqs.get(i).name);
                        fastaAlignment.add(A.seqs.get(i).sequence);
                    }
                } else if (S.type == outputTypes.OutputType.alignmentProt) { //AA alignment
                    alignmentProt A = gson.fromJson(text, alignmentProt.class);

                    //Limitation
                    if (A.seqs.get(0).sequence.length() > 10000) {
                        seqs.add(new error("Currently the limit for this tool is an alignment with maximal 1000 columns"));
                        return sendOutput(seqs);
                    }

                    title = A.name;
                    int n = A.seqs.size();
                    for (int i = 0; i < n; i++) {
                        fastaAlignment.add(">" + A.seqs.get(i).name);
                        fastaAlignment.add(A.seqs.get(i).sequence);
                    }
                    isDNA = false;
                } else {
                    seqs.add(new error("Error occured"));
                    return sendOutput(seqs);
                }

                try {

                    Process process = new ProcessBuilder("timeout", "20s", "nice", "-7", softwareDir + "weblogo", "--sequence-type", (isDNA ? "dna" : "protein"), "--format", "png", "--stacks-per-line", "50", "--fineprint", " ").start();

                    String base64String = Base64.getEncoder().encodeToString(process.getInputStream().readAllBytes());
                    BufferedReader error = new BufferedReader(new InputStreamReader(process.getErrorStream()));
                    BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(process.getOutputStream()));

                    for (int i = 0; i < fastaAlignment.size(); i++) {
                        bw.write(fastaAlignment.get(i));
                        bw.newLine();
                    }
                    bw.close();

                    String imageBase64 = " <img style=\"display:block;margin-left:auto;margin-right:auto\" src=\"data:image/png;base64,";
                    imageBase64 += base64String;
                    imageBase64 += "\">";

                    if (process.waitFor() == 124) {
                        seqs.add(new error("Timeout: Try again later or try with shorter alignment"));
                        return sendOutput(seqs);
                    }

                    seqs.add(new customText(title + " [Sequence Logo]", "", imageBase64));
                } catch (IOException e) {
                    seqs.add(new error("Error occured"));
                    return sendOutput(seqs);
                } catch (InterruptedException e) {
                    seqs.add(new error("InterruptedException"));
                    return sendOutput(seqs);
                }
            }
        }
        return sendOutput(seqs);
    }

    private String translate(String text, String translationTable, String frame, String start, String end) {
        int translationTableInt = Integer.decode(translationTable);
        ArrayList<output> seqs = new ArrayList<>();
        if (text.isEmpty()) {
            seqs.add(new error("Error occured"));
        } else {
            dna S = gson.fromJson(text, dna.class);
            if (S == null || S.sequence.isEmpty() || S.name.isEmpty() || S.mark == null) {
                seqs.add(new error("Error occured"));
            } else {
                SequenceDNA Ss = new SequenceDNA(S.sequence, false);
                boolean reverse;
                int frameInt;
                int startCodon;
                int endCodon;
                if (frame != null) {
                    reverse = frame.startsWith("R");
                    frameInt = Integer.decode(frame.substring(1));
                    startCodon = 0;
                    endCodon = Ss.getLength() - 1;
                } else {
                    reverse = false;
                    frameInt = 1;
                    startCodon = Integer.decode(start);
                    endCodon = Integer.decode(end);
                }

                Ss = Ss.getLinearSubSequence(new Position(startCodon, endCodon, reverse));

                ArrayList<mark> marksDNA = markSubsequence(S.mark, startCodon, endCodon);
                if (reverse) {
                    marksDNA = markReverse(marksDNA, Ss.getLength());
                }

                if (Ss.getLength() < 2 + frameInt) {
                    seqs.add(new error("Sequence is too short to translate Frame " + frameInt));
                } else {

                    SequenceAA Aa = SequenceTools.DNA2Protein(Ss, translationTableInt, frameInt, false);
                    System.out.println(Aa == null);

                    ArrayList<mark> marksAA = markConvertAA(marksDNA, frameInt);

                    String name = S.name;
                    if (frame != null) {
                        name += " [Translated " + (reverse ? "Reverse " : "Forward ") + " Frame " + frameInt + "]";
                    } else {
                        name += " [Translated " + (startCodon + 1) + "-" + (endCodon + 1) + "]";
                    }
                    seqs.add(new aa(name, Aa.toString(), marksAA, S.pos));
                }
            }
        }
        return sendOutput(seqs);
    }

    private String longestOrf(String text, String translationTable) {
        int translationTableInt = Integer.decode(translationTable);
        ArrayList<output> seqs = new ArrayList<>();
        if (text.isEmpty()) {
            seqs.add(new error("Error occured"));
        } else {
            dna S = gson.fromJson(text, dna.class);
            if (S == null || S.sequence.isEmpty() || S.name.isEmpty() || S.mark == null) {
                seqs.add(new error("Error occured"));
            } else {
                SequenceDNA Ss = new SequenceDNA(S.sequence, false);
                SequenceDNA Ss_rev = SequenceTools.reverseComplement(Ss, true, true);

                Position l1 = findLongest(Ss, translationTableInt);
                Position l2 = findLongest(Ss_rev, translationTableInt);

                boolean isReverse = false;

                if (l1 == null && l2 == null) {
                    seqs.add(new error(S.name + ":<br>No ORF found"));
                    return sendOutput(seqs);
                } else if (l1 == null) {
                    isReverse = true;
                } else //l2 longer than l1
                    //l1 longer than l2
                    if (l2 == null) {
                        isReverse = false;
                    } else isReverse = (l2.getEndPos() - l2.getStartPos()) > (l1.getEndPos() - l1.getStartPos());
                SequenceAA Aa = SequenceTools.DNA2Protein((isReverse ? Ss_rev : Ss).getLinearSubSequence(isReverse ? l2 : l1), translationTableInt, 1);

                ArrayList<mark> marksDNA = S.mark;
                if (isReverse) {
                    marksDNA = markReverse(marksDNA, Ss.getLength());
                }

                marksDNA = markSubsequence(marksDNA, (isReverse ? l2.getStartPos() : l1.getStartPos()), (isReverse ? l2.getEndPos() : l1.getEndPos()));

                int frame = (isReverse ? l2 : l1).getStartPos() % 3;

                ArrayList<mark> marksAA = markConvertAA(marksDNA, frame);

                String name = S.name;
                name += " [Longest ORF: " + (isReverse ? "RevComp " : "") + ((isReverse ? l2 : l1).getStartPos() + 1) + "-" + ((isReverse ? l2 : l1).getEndPos() + 1) + "nt]";
                seqs.add(new aa(name, Aa.toString(), marksAA, S.pos));
            }
        }
        return sendOutput(seqs);
    }

    private Position findLongest(SequenceDNA seq, int translationTable) {
        int[] allStarts = SequenceTools.findStartCodon(seq, translationTable);
        int[] allEnds = SequenceTools.findTerminatorCodon(seq, translationTable);

        int x = -1;
        int y = -1;
        int length = -1;

        for (int i = 0; i < allStarts.length; i++) {
            int t = findMatchingTerminator(allStarts[i], allEnds);
            if (t == -1) {
                continue;
            }
            if (allEnds[t] - allStarts[i] > length) {
                length = allEnds[t] - allStarts[i];
                x = i;
                y = t;
            }
        }
        if (x == -1) {
            return null;
        }

        return new Position(allStarts[x], allEnds[y] + 2, false);
    }

    private int findMatchingTerminator(int start, int[] possibleTerminators) {
        int frame = start % 3;
        for (int i = 0; i < possibleTerminators.length; i++) {
            if (possibleTerminators[i] <= start) {
                continue;
            }
            if (possibleTerminators[i] % 3 == frame) {
                return i;
            }
        }
        return -1;
    }

    private String translateWindow(String text, String translationTable) {
        ArrayList<output> seqs = new ArrayList<>();
        if (translationTable == null) {
            seqs.add(new error("Error occured, no TranslationTable nr"));
            return sendOutput(seqs);
        }
        int translationTableInt = Integer.decode(translationTable);

        if (text.isEmpty()) {
            seqs.add(new error("Error occured"));
        } else {
            dna S = gson.fromJson(text, dna.class);
            if (S == null || S.sequence.isEmpty() || S.name.isEmpty() || S.mark == null) {
                seqs.add(new error("Error occured"));
            } else {
                SequenceDNA s = new SequenceDNA(S.sequence, false);
                SequenceAA f1 = SequenceTools.DNA2Protein(s, translationTableInt, 1, false);
                SequenceAA f2 = SequenceTools.DNA2Protein(s, translationTableInt, 2, false);
                SequenceAA f3 = SequenceTools.DNA2Protein(s, translationTableInt, 3, false);

                if (f1 == null) {
                    f1 = new SequenceAA("-");
                }
                if (f2 == null) {
                    f2 = new SequenceAA("-");
                }
                if (f3 == null) {
                    f3 = new SequenceAA("-");
                }

                char[][] f_ = new char[3][];
                f_[0] = new char[f1.getLength()];
                Arrays.fill(f_[0], 'o');
                f_[1] = new char[f2.getLength()];
                Arrays.fill(f_[1], 'o');
                f_[2] = new char[f3.getLength()];
                Arrays.fill(f_[2], 'o');
                int[] start = SequenceTools.findStartCodon(s, translationTableInt);
                int[] stop = SequenceTools.findTerminatorCodon(s, translationTableInt);

                for (int i = 0; i < start.length; i++) {
                    int frame = start[i] % 3;
                    f_[frame][(start[i] - frame) / 3] = 'a';
                }

                for (int i = 0; i < stop.length; i++) {
                    int frame = stop[i] % 3;
                    f_[frame][(stop[i] - frame) / 3] = 'b';
                }
                seqs.add(new translateWindowClass(s.toString(), f1.toString(), f2.toString(), f3.toString(), new String(f_[0]), new String(f_[1]), new String(f_[2])));
            }
        }
        return sendOutput(seqs);
    }

    private String addSequences(String text) {
        ArrayList<outputTypes.output> seqs = new ArrayList<>();
        if (text.isEmpty()) {
            seqs.add(new outputTypes.error("Please enter a sequence"));
        } else {
            String[] lines = text.split("\\r?\\n");
            ArrayList<String> currSeq = new ArrayList<>();
            String currName = "Unnamed";
            int l = 0;
            for (String line : lines) {
                line = line.trim();
                if (line.isEmpty()) {
                    continue;
                }
                if (line.startsWith(">")) //Next seq
                {
                    if (!currSeq.isEmpty()) {
                        boolean isDNA = predictIsDNA(currSeq);
                        String sequence = (isDNA ? toDNASequence(currSeq) : toAASequence(currSeq));
                        if (!sequence.isEmpty()) {
                            if (sequence.length() > 100000) {
                                sequence = sequence.substring(0, 100000);
                                seqs.add(new outputTypes.error("The current length limit for a sequence is 100kb. The sequence has been cropped to this length"));
                            }
                            if (isDNA) {
                                seqs.add(new outputTypes.dna(currName, sequence, sequence));
                            } else {
                                seqs.add(new outputTypes.aa(currName, sequence, sequence));
                            }
                        }
                    }
                    currSeq = new ArrayList<>();
                    currName = removeCharsTitle(line.substring(1));
                } else {
                    currSeq.add(line);
                }
            }
            if (!currSeq.isEmpty()) {
                boolean isDNA = predictIsDNA(currSeq);
                String sequence = (isDNA ? toDNASequence(currSeq) : toAASequence(currSeq));
                if (!sequence.isEmpty()) {
                    if (sequence.length() > 100000) {
                        sequence = sequence.substring(0, 100000);
                        seqs.add(new outputTypes.error("The current length limit for a sequence is 100kb. The sequence has been cropped to this length"));
                    }
                    if (isDNA) {
                        seqs.add(new outputTypes.dna(currName, sequence, sequence));
                    } else {
                        seqs.add(new outputTypes.aa(currName, sequence, sequence));
                    }
                }
            }
        }

        if (seqs.isEmpty()) {
            seqs.add(new outputTypes.error("Could not parse your sequences. Please check the formatting"));
        }

        return sendOutput(seqs);
    }

    private String getConsensus(String[] alignment, boolean isProtein) {
        int length = alignment[0].length();
        byte[] consensus = new byte[length];

        for (int i = 0; i < length; i++) {
            int[] count = new int[Aminoacids.alphabetSize];
            for (int j = 0; j < alignment.length; j++) {
                count[aa.aaChar.get(alignment[j].charAt(i))]++;
            }

            //get max and second max
            //count[0] are gaps
            byte highest = (count[1] > count[2] ? (byte) 1 : (byte) 2);
            byte second = (count[1] > count[2] ? (byte) 2 : (byte) 1);

            for (byte j = 3; j < Aminoacids.alphabetSize; j++) {
                if (count[j] > count[highest]) {
                    second = highest;
                    highest = j;
                } else if (count[j] > count[second]) {
                    second = j;
                } else if (count[j] == count[highest]) {
                    second = j;
                }
            }

            if (count[Aminoacids.__] > count[highest]) {
                consensus[i] = Aminoacids.__;
            } else if (count[highest] == count[second]) {
                if (isProtein) {
                    consensus[i] = Aminoacids._X;
                } else {
                    //Check if third variant with same count as highest=second exists, in that case assign N
                    boolean third = false;
                    for (byte j = 1; j < Aminoacids.alphabetSize; j++) {
                        if (j == highest || j == second) {
                            continue;
                        }
                        if (count[j] == count[highest]) {
                            third = true;
                            break;
                        }
                    }
                    if (third) {
                        consensus[i] = Aminoacids._N;
                    } else {
                        //Only use ambigous nucs for cases where highest and second chars have the same counts, but third highest count is lower
                        char ambi = nucl.ambigous(aa.OneLetterChar[highest], aa.OneLetterChar[second]);
                        consensus[i] = aa.aaChar.get(ambi);
                    }
                }
            } else {
                consensus[i] = highest;
            }
        }
        consensus = aa.killGaps(consensus);

        return (new SequenceAA(consensus).toString());
    }

    private ArrayList<mark> removeMark(ArrayList<mark> marks, int start, int end, boolean removeColor, boolean removeAnnotation) {

        if (start > end) {
            int b = end;
            end = start;
            start = b;
        }
        for (int i = 0; i < marks.size(); i++) {
            if (marks.get(i).type < 100) {//is color
                if (!removeColor) {
                    continue;
                }
            } else { //is annotation
                if (!removeAnnotation) {
                    continue;
                }
            }
            boolean reverse = (marks.get(i).stop < marks.get(i).start);
            int markstop = (reverse ? marks.get(i).start : marks.get(i).stop);
            int markstart = (reverse ? marks.get(i).stop : marks.get(i).start);
            if (markstop < start) {
                continue;
            }
            if (markstart > end) {
                continue;
            }
            if (markstart >= start && markstop <= end) //old mark completely enclosed in new mark, delete old
            {
                marks.remove(i);
                i--;
            } else if (markstart < start && markstop > end) {
                String markname = marks.get(i).name;
                int marktype = marks.get(i).type;
                marks.remove(i);
                if (reverse) {
                    marks.add(i, new mark(marktype, start - 1, markstart, markname));
                    marks.add(i + 1, new mark(marktype, markstop, end + 1, markname));
                } else {
                    marks.add(i, new mark(marktype, markstart, start - 1, markname));
                    marks.add(i + 1, new mark(marktype, end + 1, markstop, markname));
                }
                i++;
            } else if (markstart < start) {
                if (reverse) {
                    marks.get(i).start = start - 1;
                } else {
                    marks.get(i).stop = start - 1;
                }
            } else {
                if (reverse) {
                    marks.get(i).stop = end + 1;
                } else {
                    marks.get(i).start = end + 1;
                }
            }
        }
        return marks;
    }

    private ArrayList<mark> addMark(ArrayList<mark> marks, int start, int end, int type) {

        if (start > end) {
            int b = end;
            end = start;
            start = b;
        }
        for (int i = 0; i < marks.size(); i++) {

            if (marks.get(i).type >= 100) {
                continue;
            }
            if (marks.get(i).stop < start) {
                continue;
            }
            if (marks.get(i).start > end) {
                break;
            }
            if (marks.get(i).start >= start && marks.get(i).stop <= end) //old mark completely enclosed in new mark, delete old
            {
                marks.remove(i);
                i--;
            } else if (marks.get(i).start < start && marks.get(i).stop > end) {
                marks.add(i, new mark(marks.get(i).type, marks.get(i).start, marks.get(i).stop, marks.get(i).name));
                marks.get(i).stop = start - 1;
                marks.get(i + 1).start = end + 1;
            } else if (marks.get(i).start < start) {
                marks.get(i).stop = start - 1;
            } else {
                marks.get(i).start = end + 1;
            }
        }
        boolean added = false;
        for (int i = 0; i < marks.size(); i++) {
            if (marks.get(i).start < start) {
                continue;
            } else {
                marks.add(i, new mark(type, start, end, ""));
                added = true;
                break;
            }
        }
        if (!added) {
            marks.add(new mark(type, start, end, ""));
        }
        return marks;
    }

    private ArrayList<mark> addMarkAnnotation(ArrayList<mark> marks, int start, int end, String annotation, int color) {
        int bend = end;
        int bstart = start;

        if (start > end) {
            bend = start;
            bstart = end;
        }
        for (int i = 0; i < marks.size(); i++) {

            if (marks.get(i).type < 100) {
                continue;
            }

            boolean reverse = (marks.get(i).stop < marks.get(i).start);
            int markstop = (reverse ? marks.get(i).start : marks.get(i).stop);
            int markstart = (reverse ? marks.get(i).stop : marks.get(i).start);

            if (markstop < bstart) {
                continue;
            }
            if (markstart > bend) {
                break;
            }
            if (markstart >= bstart && markstop <= bend) //old mark completely enclosed in new mark, delete old
            {
                marks.remove(i);
                i--;
            } else if (markstart < bstart && markstop > bend) {
                marks.add(i, new mark(marks.get(i).type, marks.get(i).start, marks.get(i).stop, marks.get(i).name));
                if (reverse) {
                    marks.get(i).start = bstart - 1;
                    marks.get(i + 1).stop = bend + 1;
                } else {
                    marks.get(i).stop = bstart - 1;
                    marks.get(i + 1).start = bend + 1;
                }
            } else if (markstart < bstart) {
                if (reverse) {
                    marks.get(i).start = bstart - 1;
                } else {
                    marks.get(i).stop = bstart - 1;
                }
            } else {
                if (reverse) {
                    marks.get(i).stop = bend + 1;
                } else {
                    marks.get(i).start = bend + 1;
                }
            }
        }
        boolean added = false;
        for (int i = 0; i < marks.size(); i++) {
            if ((marks.get(i).start > marks.get(i).stop ? marks.get(i).stop : marks.get(i).start) < bstart) {
                continue;
            } else {
                marks.add(i, new mark(color, start, end, annotation));
                added = true;
                break;
            }
        }
        if (!added) {
            marks.add(new mark(color, start, end, annotation));
        }
        return marks;
    }

    private String sendOutput2(ArrayList<findMarks> seqs) {
        String json = gson.toJson(seqs);
        return json;
    }

    private String sendOutput(ArrayList<output> seqs) {
        String json = gson.toJson(seqs);
        return json;
    }

    private static String removeCharsTitle(String str) {
        return str.replaceAll("[^\\w\\s()\\(\\)\\{\\}\\[\\]\\-\\'\\,\\.]", "_").trim();
    }

    private static boolean predictIsDNA(ArrayList<String> lines) {
        String lookingAt = lines.get(0) + (lines.size() > 1 ? lines.get(lines.size() - 1) : "");
        lookingAt = lookingAt.toUpperCase();

        int pointDNA = 0;
        int pointAA = 0;

        for (char c : lookingAt.toCharArray()) {
            String cd = Character.toString(c);
            if (cd.matches("[ACGTRYSWKMBDHVN]")) { //possible DNA letters
                pointDNA++;
            }
            if (cd.matches("[ABCDEFGHIKLMNPQRSTVWYZX]")) { //possible AA letters
                pointAA++;
            }
        }
        return pointAA <= pointDNA;
    }

    private static String toDNASequence(ArrayList<String> lines) {
        String out = "";
        for (int i = 0; i < lines.size(); i++) {
            String l = lines.get(i);
            out += convertDNASequence(l);
        }
        return out;
    }

    private static String toAASequence(ArrayList<String> lines) {
        String out = "";
        for (int i = 0; i < lines.size(); i++) {
            String l = lines.get(i);
            out += convertAASequence(l);
        }
        return out;
    }

    private ArrayList<mark> markSubsequence(ArrayList<mark> marks, int start, int stop) {
        ArrayList<mark> newMarks = new ArrayList<>();

        for (mark m : marks) {
            int newMarkStart;
            int newMarkEnd;
            if (m.start > stop || m.stop < start) {
                continue;
            }
            if (m.start > start) {
                newMarkStart = m.start - start;
            } else {
                newMarkStart = 0;
            }
            if (m.stop < stop) {
                newMarkEnd = m.stop - start;
            } else {
                newMarkEnd = stop - start;
            }
            newMarks.add(new mark(m.type, newMarkStart, newMarkEnd, m.name));
        }
        return newMarks;
    }

    private ArrayList<mark> markConvertAA(ArrayList<mark> marks, int frame) {
        ArrayList<mark> marksAA = new ArrayList<>();
        for (mark m : marks) {
            if (m.stop + 1 < frame) {
                continue;
            }
            int start = (m.start - frame + 1) / 3;
            if ((m.start - frame + 1) % 3 > 0) {
                start++;
            }
            if (start < 0) {
                start = 0;
            }
            int stop = (m.stop - frame + 1) / 3;
            if ((m.stop - frame + 1) % 3 < 2) {
                stop--;
            }

//            if (stop < start) {
//                continue;
//            }
            if (stop < 0) {
                stop = 0;
            }
            marksAA.add(new mark(m.type, start, stop, m.name));
        }
        return marksAA;
    }

    private ArrayList<mark> markReverse(ArrayList<mark> marks, int sequenceLength) {
        ArrayList<mark> reverseMarks = marks;
        Collections.reverse(reverseMarks);
        int seqlength = sequenceLength;
        for (mark m : reverseMarks) {
            int start = seqlength - m.stop - 1;
            int stop = seqlength - m.start - 1;
            if (m.type >= 100) {
                int b = start;
                start = stop;
                stop = b;
            }
            m.start = start;
            m.stop = stop;
        }
        return reverseMarks;
    }

    private static String convertDNASequence(String s) {
        String l = s.replaceAll("[\\s\\-\\.0-9]", "").toUpperCase();
        l = l.replace('U', 'T');
        l = l.replaceAll("[^ACGTRYSWKMBDHV]", "N");
        return l;
    }

    private static String convertAASequence(String s) {
        String l = s.replaceAll("[\\s\\-\\.0-9]", "").toUpperCase();
        l = l.replaceAll("[^ABCDEFGHIKLMNPQRSTVWYZ\\*]", "X");
        return l;
    }

    public static String sanitizeString(String s) {
        return s.replaceAll("[<>]", "_");
    }

    public String generateDbKey() {
        String key = new BigInteger(40, random).toString(32);
        if (key.length() != 8) {
            return generateDbKey();
        }
        return key;
    }

}
